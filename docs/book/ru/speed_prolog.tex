\documentclass[a4paper]{book}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\selectlanguage{russian}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{underscore} % no need to escape 
                        % underscore with this pack

\renewcommand{\labelenumii}{\asbuk{enumii})}

\def\tn{т.\thinspace н.}
\def\td{т.\thinspace д.}
\def\tp{т.\thinspace п.}
\def\to{т.\thinspace о.}
\def\To{Т.\thinspace о.}
\def\te{т.\thinspace е.}
\def\Te{Т.\thinspace е.}
\def\itd{и т.\thinspace д.}
\def\ur{Uranium}

\hypersetup{%
    pdfborder = {0 0 0}
}

\lstnewenvironment{example}[2]%
   {%
    \minipage[t]{0.9\linewidth}%
    \lstset{language=Prolog, frame=single, breaklines=true,%
            breakatwhitespace=true,%
            basicstyle=\small,%
            frameround=fttt,frame=trBL,%
            caption={#1},label={#2}}%
   }%
   {\endminipage\smallskip}

\lstnewenvironment{bigexample}[2]%
   {%
    \lstset{language=Prolog, frame=single, breaklines=true,%
            breakatwhitespace=true,%
            basicstyle=\small,%
            xrightmargin=0.05\linewidth,%
            xleftmargin=0.05\linewidth,%
            frameround=fttt,frame=trBL,%
            caption={#1},label={#2}}%
   }%
   {\smallskip}

\lstnewenvironment{genexample}[2]%
   {%
    \minipage[t]{0.9\linewidth}%
    \lstset{frame=single, breaklines=true,%
            breakatwhitespace=true,%
            basicstyle=\small,%
            frameround=fttt,frame=trBL,%
            caption={#1},label={#2}}%
   }%
   {\endminipage\smallskip}

\begin{document}
\title{Неформальное практическое\\ введение в язык\\ Пролог}
\author{Сергей Лодягин\\ \texttt{lodyagin@gmail.com}}

\date{\today}
\maketitle

\tableofcontents

%\subsection*{Preface}
%\addcontentsline{toc}{subsection}{Preface}

\chapter*{Предисловие}
\addcontentsline{toc}{chapter}{Предисловие}

Эта небольшая книжка возникла в преддверии конференции OSDN 2011
(\url{http://conference.osdn.org.ua}), где автор планирует
произнести доклад на тему своей новой системы автоматического
тестирования ПО под названием \ur. Система открыта, защищена
лицензией LGPL и написана на Прологе. Код системы и документация
доступны по адресу 
\\ 

\url{http://uranium-test.sourceforge.net}.
\\ 

В ходе распространения данной системы её разработчики (которые
сами успешно используют систему в коммерческих проектах по
тестированию) столкнулись с некоторыми стереотипами относительно
самого языка Пролог. Стереотипы эти обусловлены, вероятно,
недостаточным уровнем подготовки специалистов именно в аспекте
практического использования логического программирования. И в то
время, как большинство выпускников ВУЗов логическое
программирование изучают и имеют хороший потенциал, и зачастую,
талант, на практике его могут использовать исчезающе малое
количество профессионалов.

И дело тут, как считает автор, не столько в самом подходе,
сколько в устоявшихся и ничем не обоснованных взглядах, которые
вбиваются в голову как студентам, так и просто читателям
литературы по этому языку. Представьте себе, на одной встрече
руководитель одной из компаний, где мы предлагали запустить
проект автоматического тестирования на базе \ur{} сказал примерно
следующее : 

- Пролог? А это язык, который позволяет строить генеалогические
деревья для собак? А причём тут тестирование?

Пришлось ему открыть глаза, что это не только для собак. Что,
например, рутинную работу по анализу предложения на рынке через
Web, автоматический сбор и анализ прайсов и динамическое
размещение ассортимента по страницам сайта, пересчёт цен, вплоть
до рассылки рекламных писем постоянным клиентам можно
запрограммировать на Прологе. Я не знаю дальнейшую судьбу той
компании, но могу уверенно предположить, что существует много
компаний, где бы методики логического программирования принесли
бы непосредственный прирост прибыли и нашлись бы программисты,
которые бы эти методики могли освоить и внедрить, оттолкнувшись,
хотя бы от от институтского курса\footnote{В одной из компаний со
  штатом около 20 человек нашлось 2 программиста из числа людей,
  которые занимались ручным тестированием, которые, после
  открытия проекта на языке Пролог на следующий день начали на
  нём программировать и через 2 недели уже решали практические
  задачи}. Просто, они тоже, вероятно думают, что Пролог - это
инструктирование обезьяны по поиску банана в каком-то
абстрактном, оторванном от реальности мире.

И это не недостаток самого языка, это недостаток имеющейся
литературы. При написании документации по системе \ur{} автор
пришёл в замешательство, когда просмотрел те книги, которые он
сам думал рекомендовать для освоения языка\footnote{Вот цитата,
  из одной предисловия недавно изданной на русском языке книге по
  Прологу: ``Prolog особенно хорошо подходит для решения задач, в
  которых рассматриваются объекты (в частности, структурированные
  объекты) и отношения между ними. Например, на языке Prolog
  совсем не сложно выразить пространственные связи между
  объектами, допустим, указать, что {\bf синий шар находится за
    зеленым}.''}

То, что в своё время Пролог считался языком академическим и о нём
писали в соответствующем духе, было обусловлено тем, что в то
время, когда учились эти авторы, практические задачей для машины
были, в подавляющем своём большинстве, расчётными. Анализом
строк, зависимостей между объектами и \tp, для чего изначально
язык Пролог очень хорошо подходил, занимались больше в
академической среде. Разве это то, что мы имеем сейчас? Все эти
задачи давно стали mainstream.

Это побудило автора на какое-то время отвлечься от разработки
документации собственно по библиотеке \ur{} и написать раздел по
введению в язык Пролог, который превратился в самостоятельное
изложение, которое и предлагается вашему вниманию. 

Для запуска примеров вам необходимо установить SWI-Prolog,
который можете свободно скачать с сайта
\url{http://swi-prolog.org}. Документацию по системе можно найти
там же. Следует сказать, что во многом и сама система \ur{} и
данное изложение вдохновлены этой замечательной свободной
реализацией языка.

Здесь же следует добавить, что Пролог, ввиду своей исключительной
логической гибкости, очень хорошо подходит для последовательного
решения задач и не требует такой длительной фазы проектирования,
как например, при использовании Java, а потому является, пожалуй,
королём прототипов; основной способ проектирования программы в
Прологе --- эволюционный, путём постоянных запросов и дописания
необходимых предикатов является идеально настроенным на получение
наискорейшей цели, что является важным, когда нам надо, например,
написать автоматический тест (это одна из причин, почему
библиотека \ur{} написана именно на Прологе).

Автор выражает благодарность всем, кто нашёл время прочитать и
покритиковать начальные версии ``Введения в язык Пролог'', равно
как и остальной документации по системе \ur. (Вы можете найти её
в электронном виде на странице проекта).

\chapter{Введение в язык Пролог}

Язык Пролог является языком логического программирования. Это
значит, основным цементов, соединяющим компоненты программы
является не столько последовательность операторов, сколько
логика. 

Опишем сначала общие черты, отталкиваясь от алгоритмической
модели, а потом сконцентрируемся на различиях.

\section{Hello, World!}

Вот, собственно, классический пример.

\begin{example}{}{}
first_predicate :-

   writeln('Hello, logical world!').
\end{example}

Если провести аналог с процедурным подходом, то каждая
``процедура'' (в Прологе она называется ``предикатом'')
начинается с головы, за которой следует `:-' и тело,
завершающееся точкой. Такие определения записываются в файл друг
за другом. Файл, как правило, определяет модуль, но, если, имя
модуля не указывается, то определения попадают в модуль
по-умолчанию, который называется user.

Если приведённый пример сохранить в файл (например, hello.pl, для
работы данного примера только называйте файл с маленькой буквы),
то, запустив командную строку Пролога его можно загрузить
следующим образом.

\begin{example}{}{}
?- [hello].
% hello compiled 0.00 sec, 224 bytes
true.
\end{example}

`?-' - это приглашение к вводу запроса, а true - это сообщение
Пролога, которое, в данном случае, говорит, что команда загрузки
завершилась. Обратите внимание - запрос, как и определение
предиката, завершается точкой.

Запустить ``изнутри Пролога'' нашу программу можно следующим
образом:

\begin{example}{}{}
?- first_predicate.

Hello, logical world!
true.
\end{example}

Такой способ является очень удобным для отладки программ.

Если есть необходимость сделать исполнимый файл, то есть много
способов. При использовании SWI Prolog один из вариантов
следующий:

\begin{example}{}{}
swipl --goal=first_predicate --stand_alone=true -t halt -o hello -c hello.pl
\end{example}

после чего будет получен обычный исполнимый файл hello (с точкой
входа first_predicate).

Однако, для основной работы с \ur{} больше всего подходит
командная строка. А в готовые исполнимые файлы можно помещать
только уже полностью отлаженные тесты.

\section{Процесс написания программы}

Можно подредактировать исходный файл, например так:

\begin{example}{}{}
first_predicate :-

   writeln('Hello, logical world!'),
   writeln('I am new here.').
\end{example}

Запятая между вызовами предиката writeln из пакета system (этот
пакет содержит предопределённые базовые предикаты и всегда виден
из любого другого пакета) играет роль разделителя, подобно тому,
как `;' в Java. Применить изменения можно с помощью того же
запроса \verb|[hello].| или \verb|make.| (make --- удобный
предикат, он автоматически обновляет все загруженные ранее
файлы).

Добавим в файл\footnote{можно и в другой} ещё один предикат:

\begin{example}{}{}
second_predicate(Name) :-

  first_predicate,
  write('My name is '), write(Name), nl.
\end{example}

Предикат принимает один параметр (в Прологе говорят, что он
обладает {\it арностью\/} 1. first_predicate --- арностью 0).

Теперь мы можем вызывать и первый и второй независимо друг от
друга. При этом second_predicate вызывает first_predicate на
подобии процедуры.

\begin{example}{}{}
?- second_predicate('Sergei').

Hello, logical world!
I am new here.
My name is Sergei
true.
\end{example}

Кавычки для строки (которая в Прологе называется {\it атомом\/})
обязательны, если только атом не начинается с маленькой
буквы. (Для этого мы назвали файл с маленькой буквы, чтобы
сэкономить на кавычках. Однако, если файл находится не в текущем
каталоге и нам необходимо задавать путь, кавычки могут быть
необходимы.)

\section{Термы}
\label{terms}

Терм - это ёмкое понятие, которое объединяет числа, атомы,
переменные и структуры. Строго говоря, кроме термов, скобок и
завершающей точки в Прологе, пожалуй, ничего и нет. Однако, такой
скупой набор базовых концепций обеспечивает большие возможности.

\begin{description}
\item атом --- это всегда атом, но, с точки зрения синтаксического
  анализатора Пролога, он бывает трёх подтипов:
  \begin{itemize}
    \item[1)] последовательность букв, цифр и символов
      подчёркивания, начинающаяся с маленькой буквы: \verb|a|,
      \verb|good_wether|, \verb|myFriend|, \verb|be2|,
      \verb|крокодил|. Эта форма удобна как аналог enumerated
      типов многих языков. Например, можно оперировать цветами:
      \verb|green|, \verb|cyan|, \verb|magenta|, булевскими
      константами \verb|true, false| или обозначать
      математические константы, например \verb|pi|;
    \item[2)] последовательность операторных символов
      произвольной длины. К операторным символам относятся:
      \verb|+-*/^=~:;.?@$\`#<>|. Последовательность, состоящая из
      одного и более таких символов является тоже атомом и с ней
      можно оперировать точно также, как с любым другим атомом;
      однако некоторые из таких атомов можно, дополнительно,
      объявить {\it операторами\/}, после чего синтаксический
      анализатор будет группировать вокруг них другие термы по
      особым правилам; но, в принципе, они всегда остаются атомами;
    \item[3)] последовательность любых символов Unicode,
      заключённая в одинарные кавычки. Сама кавычка внутри
      последовательности должна писаться как \verb|''| или
      \verb|\'|; к этой форме всегда можно свести две предыдущие,
      \te \verb|'true'| и \verb|true|, \verb|'='| и \verb|=| -
      одно и тоже; эта форма нужна исключительно либо когда атом
      не начинается с маленькой буквы, либо когда содержит
      специальные (непечатаемые) символы, либо сочетает
      операторные символы с другими символами, либо это \verb|''|
      - пустой атом (не содержащий символов вообще). 
  \end{itemize}
  Подводя итог этих трёх форм, можно сказать, что атом - это
  enumerated тип, строка и оператор в одном флаконе (вообще, само
  понятие ``атом'' как бы исключает строки и, действительно,
  строки в Прологе могут представляються как структуры, но,
  для удобства работы, в \ur{} они очень часто обрабатываются в
  виде атомов).

  \item число --- оно и в Прологе
    число. \verb|5, -0.2, +8, 1e-5|. Целое число не имеет
    максимального и минимального значения. Просто, чем больше
    число, тем больше памяти оно будет занимать. Для fixed point
    можно использовать рациональные числа, которые, однако,
    синтаксически будут относится уже не к числам, а к
    структурам, потому что они представляются как два целых числа
    - числитель и знаменатель.

  \item переменная --- всё, что начинается с большой буквы или
    символа подчёркивания и не заключено в кавычки. \To для
    различения переменных и атомов мы будем использовать либо
    регистр первой буквы, либо одинарные кавычки. Переменная не
    имеет типа и может содержать всё, что угодно.

  \item структура --- атом, за которым следует последовательность
    термов, отделённых запятыми и заключённая в скобки. Например,
    \verb|write(Name)| - это структура, равно как и
    \verb|point3D(0.0, 1.0, 2.0)| (между атомом и открывающейся
    скобкой не должно быть пробела!). То что в первом случае это
    предикат, а во втором - объект данных Пролог узнает из
    контекста\footnote{На самом деле, голова предиката --- это та
      же структура. А то, что при написании этой структуры в
      выражении вызывается предикат из базы Пролога --- это
      скрытая работа виртуальной машины Пролога. В принципе,
      любую структуру можно попытаться вызвать таким же образом,
      с помощью предиката call, однако, для возможности
      исполнения она должна находиться в базе.}.
\end{description}

\section{Модель исполнения}
\label{prolog_execution_model}

Необходимо сказать несколько слов о модели исполнения.  В центре
Пролога находится база данных, которая, одновременно, и является
программой. Наши определения first_predicate и second_predicate
после чтения из файла исходного кода и компиляции попадают в эту
базу данных. В неё можно заглянуть, например, с помощью предиката
clause\footnote{Более просто это делать с помощью предиката
  listing, однако он больше подходит для распечатки, чем для
  работы с базой программы, которую мы хотим продемонстрировать}:

\begin{example}{}{}
?- clause(first_predicate, Body).

Body = (writeln('Hello, logical world!'), writeln('I am new here.')).                                                       
\end{example}

Предикат clause извлёк запись из базы по атому - имени
предиката и поместил тело предиката в переменную, которую мы
подставили на второе место в запросе. Мы говорим, что clause
имеет арность 2 (пишем clause/2), так как, грубо говоря,
принимает 2 параметра.

Запрос  

\begin{example}{}{}
?- clause(second_predicate, B).
false.
\end{example}

дал false. Потому, что арность second_predicate равна 1 и потому
его надо передать в виде структуры, вот так:

\begin{example}{}{}
?- clause(second_predicate(A), B).                        
B = (first_predicate, write('My name is '), write(A),
 nl).                                                    
\end{example}

(Обратите внимание, переменные начинают использоваться сразу
после того, как они встречаются в программе. В ответе Пролога он
уже использует предложенную нами, в качестве параметра,
переменную A для того, чтобы показать связь параметра с телом
предиката).

Вообще говоря, мы можем добавить определение и
second_predicate/0:

\begin{example}{}{}
second_predicate :-

   second_predicate('Anon').
\end{example}

и тогда и запрос second_predicate/1 и second_predicate/0 будет
давать каждый свой результат. Различение предикатов в базе всегда
происходит по атому-имени (это имя, по аналогии с математикой,
называется {\it функтором\/}) и арности. (Важно понимать, что и
при поиске определения предиката через clasue и при его вызове
используется один и тот же механизм поиска).

Типы аргументов в выборе предиката тоже могут играть
роль. Однако, в Прологе типы аргументов никогда не декларируются,
равно как и типы переменных. Мы бы могли сделать такой вызов:

\begin{example}{}{}
?- second_predicate(name_surname('Ivan', 'Susanin')).

Hello, logical world!
I am new here.
My name is name_surname(Ivan,Susanin)
\end{example}

и тоже получить результат. Переданная структура name_surname тоже
есть терм и он тоже будет печататься через write. Но вместе с тем
это и удобный механизм типизации ``на лету''.

Если мы хотим сделать различие в обработке типов атом и
name_surname/2, то должны написать отдельную форму
second_predicate/1 и поместить в текст программы её {\bf до}
общей формы (до имеющегося уже second_predicate/1), вот так:

\begin{example}{}{}
second_predicate(name_surname(Name, Surname)) :-

   concat_atom([Name, Surname], ' ', Full_Name),
   second_predicate(Full_Name), !.

second_predicate(Name) :-

  first_predicate,
  write('My name is '), write(Name), nl.

\end{example}

concat_atom/3 используется для склейки атомов. Первый параметр -
это новая для нас форма записи структуры, которая называется
списком (в прологе она часто заменяет также массивы), второй
параметр - разделитель в процессе склеивания элементов списка,
третий принимает новый атом-результат. \verb|!| останавливает
Пролог от поиска других определений second_predicate/1 после
выполнения этого. Если его убрать, то запрос через командную
строчку Пролога вернёт сначала один возможный результат а потом
спросит, не хотим ли мы ещё варианты, и вернёт второй:

\begin{example}{}{}
?- second_predicate(name_surname('Ivan', 'Susanin')).
Hello, logical world!
I am new here.
My name is Ivan Susanin
true 

%Prolog is waiting

; % we say that we would like more variants

Hello, logical world!
I am new here.
My name is name_surname(Ivan,Susanin)
true.
\end{example}

Это говорит о том, что выполнение запроса к программе на Прологе
имеет много общих черт с запросом к базе данных.

Подведём итог. В центре модели исполнения стоит база данных. Мы
изучили способ её модификации, основанный на изменении внешних
файлов и их загрузки с помощью \verb|[<имя файла>]| (это
сокращённая форма записи предиката consult/1) и make/0. (Пролог
помнит, откуда он брал предикаты, и изменение файла и перечитка
файла c помощью consult или make - эффективный способ обновления
базы Пролога). Также мы научились делать запросы из командной
строки пролога, позволяющие выбирать отдельные предикаты из базы
как на исполнение, так и на просмотр и строить исполнимые
файлы. Перейдём, непосредственно, к конструкциям, позволяющим нам
писать программы.

\section{Представление данных}

Допустим, мы хотим хранить список ссылок на любимые сайты и
каждый день отслеживать, что на сайтах поменялось.

Давайте решать задачу последовательно.

В Прологе мы пляшем от данных (поскольку, как мы видели, в
Прологе даже программа --- данные). Как мы будем хранить ссылки?

Если вы привыкли программировать на C или Java вы можете
вспомнить о файлах. Да, файл --- отличная концепция на уровне
операционной системы, но, более-менее сложная программа
использует уже в какой-то форме базу данных, предоставляющую
абстракцию куда более высокого уровня. В Прологе даже
наипростейшая программа использует базу данных, потому что эта
база данных --- база данных Пролога, всегда под рукой.

Действительно в базе данных Пролога, с которой мы уже
познакомились, компилируя туда свои предикаты и запуская/извлекая
их, можно хранить, грубо говоря, не только код, но и данные.

Для примера, создайте файл и заполните его своими ссылками. Вот,
что сделал я:

\begin{example}{Модуль sites}{module_sites_sample}
:- module(sites, [site/1]).

site('www.classicfm.co.uk').
site('www.gismeteo.ua').
site('uranium-test.sourceforge.net').
site('kogorta.dp.ua').
\end{example}

Первым делом я объявил модуль с помощью специальной директивы
':-' (она отмечает декларативную часть, которая не помещается в
базу данных при компиляции файла, а указывает, как файл должен
обрабатываться) и предиката module/2, первым параметром которого
идёт имя модуля, а вторым - список экспорта. В данном случае, я
экспортирую всего один предикат - site/1, который, тем не менее,
задан очень разнообразно. Это предикат-факт, он не имеет тела, а
имеет только голову. Обратите внимание - атомы-url заключены в
кавычки. Это потому, что они смешивают символы двух классов в
один атом (\verb|swi-prolog.com| без кавычек читалось бы как 5
атомов, вторым из которых был бы атом '-', являющийся, в добавок,
ещё и стандартным оператором). После подгрузки модуля он
экспортируется в модуль user:    

\begin{example}{}{}
?- [sites].
% sites compiled into sites 0.00 sec, 2,416 bytes
true.

?- site(Site).
Site = 'www.classicfm.co.uk' ;
Site = 'www.gismeteo.ua' ;
Site = 'uranium-test.sourceforge.net' ;
Site = 'kogorta.dp.ua'.
\end{example}

Как и в случае примера с second_predicate/1 без `!', я управлял
выдачей очередного варианта из базы печатью ';'. (Если бы мне
было нужно напечатать только самый первый сайт, я бы написал
запрос так: \verb|site(Site), !.|). 

В базе данных Пролога порядок просмотра играет очень большую
роль. Когда вы пишете файл, то Пролог помещает предикаты в базу в
том же порядке, в котором они встречаются в файле.

\section{Более сложные запросы}

Глядя на данные возникает, например, желание посмотреть
содержимое какого-либо сайта.

\begin{example}{}{}
?- [library(http/http_client)].

?- site(Site), !, http_get(Site, Html, []).
\end{example}

http/http_clist - это стандартная библиотека SWI-Prolog (что мы
указали, поместив путь как компонент структуры library/1). Первые
два элемента запроса нам уже знакомы - это чтение первого url из
базы.  http_get выполняет http запрос и помещает считанную
страницу в переменную Html. В виде html текста она не очень,
очевидно, полезна, потому неплохо было бы добавить её разбор. Для
этого достаточно подгрузить необходимый плугин, который делает
преобразование результата http запроса:

\begin{example}{Получение DOM}{GetDOM}
?- [library(http/http_sgml_plugin)].                  

?- site(Site), !, http_get(Site, Html, []).
Site = 'www.classicfm.co.uk',
Html = [element(html, [lang=en, version='-//W3C//DTD HTML 4.0 Transitional//EN'], [element(head, [], [element(meta, ['http-equiv'='content-type', content='text/html; charset=utf-8'], []), element(title, [], ['Classic FM - Classical Music Radio']), element(meta, [... = ...|...], []), element(meta, [...|...], []), element(..., ..., ...)|...]), element(body, [class='s_green home', id=sectional3], ['    ', element(script, [... = ...], ['document.body.className = ((document.body.className) ? document.body.className + \'js\' : \'js\');']), '\n    \n    \n    ', element(..., ..., ...)|...])])].                                                      
\end{example}

Пролог при печати переменной произвёл сокращения (это не более,
чем отладочная печать). Для вывода содержимого Html можно
использовать уже знакомый нам предикат write/1:

\begin{example}{}{}
?- site(Site), !, http_get(Site, Html, []), write(Html).
\end{example}

Можно видеть, что страница имеет какую-то сложную структуру, но,
из-за обилия информации разобраться в ней очень сложно.

Прежде чем посмотреть, какие средства стандартной библиотеки SWI
Prolog можно использовать для её анализа, давайте немного
разберёмся с тем, что представляют собой прологовские переменные.

\section{Унификация}

Переменные Пролога - это часть механизма, называемого
унификацией. Своей идеей он обязан математике. Когда вы пишете,
например $A = 1, B = 1, C = A + B$ в математике, это равнозначно
$A = B, 1 = A, C = A + B$. То же самое можно написать и в
Прологе:

\begin{example}{}{}
?- A = 1, B = 1, C = A + B.
A = B, B = 1,
C = 1+1.

?- A = B, 1 = A, C = A + B.
A = B, B = 1,
C = 1+1.
\end{example}

Как видите, Пролог дружит с алгеброй. Более того, неожиданный
чисто алгебраический результат $C=1+1$ явно говорит об
аналитической направленности Пролога как инструмента. (Тех, кто
не равнодушен к бухгалтерии спешу успокоить: поменяйте
\verb|C = A + B| на \verb|C is A + B|. Новички думают, что в
Прологе алгебра имеет приоритет над арифметикой. На самом деле он
легко справляется и с тем, и с другим).

Ну вот. А теперь о том, как это всё работает.

Вы, конечно, знаете, что в мире языков программирования долго
велись споры об использовании указателей. Многие их не любят. Они
могут указывать не туда, могут не инициализироваться правильно,
могут не копироваться, память может не освобождаться или
освобождаться не правильно \itd. Пролог был всегда в стороне от
этих споров, потому что

\begin{itemize}
\item[а)] в Прологе всегда был сборщик мусора;
\item[б)] в Прологе всегда была виртуальная машина;
\item[в)] Пролог настолько тщательно скрывает свою внутреннюю
  кухню, что о его изначальной дружбе с указателями мало кто
  знал
\end{itemize}

На самом деле, создатели различных языков черпали многие идеи в
Прологе. Что удивительно, сам Пролог от этого не стал хуже. Сами
того не подозревая, они сослужили Прологу хорошую службу ---
теперь можно всё объяснить по аналогии с более известными языками.

Представьте, что у вас есть указатель, на который вы наложили
такие правила:

\label{unify_rules}
\begin{itemize}
\item[1)] любой указатель всегда имеет начальное значение ---
  неинициализированный указатель указывает сам на себя (1);
\item[2)] операция присваивания над указателями запрещена; вместо
  неё есть операция унификации двух указателей
  \verb|unify(A, B)|, которая может вернуть true или false и
  работает следующим образом:
  \begin{description}
    \item если указатели A и B содержат один и тот же адрес,
      вернуть true (2)
    \item если указатель указывает на другой указатель,
      выполнять разыменование до тех пор, пока он либо не будет
      указывать сам на себя, либо будет указывать на какой-либо
      объект; после этого выполнить \verb|unify(A', B')| над
      новыми указателями (3)
    \item если один из указателей не указывает на конечный
      объект, то присвоить ячейке, на которую он указывает,
      значение другого указателя (4)
    \item если оба указателя указывают на конечный объект и это
      не структура, вернуть true если объект имеет одно и то же
      значение и false в противном случае (5)
    \item если оба указателя указывают на конечный объект и это
      структура с одним и тем же функтором и арностью, то
      выполнить unify попарно для аргументов этих структур (6)
    \item в противном случае вернуть false (7)
  \end{description}
\end{itemize}

Проиллюстрируем, как это работает. Как вы поняли, переменная
Пролога - это указатель. Когда переменная встречается первый раз
в выражении, мы имеем новый указатель (выражение заканчивается на
первой точке, потом уже идёт другое выражение с новым
пространством имён).

\begin{example}{}{}
?- writeln(A).
_G2088
\end{example}

Это неинициализированный указатель (1) (значение 2088 - адрес
ячейки для отладки; в этой ячейке находится указатель на себя).

Операция унификации в Прологе записывается как '='

\begin{example}{}{}
?- A = B, write((A, B)).

_G2088,_G2088
\end{example}

Это значит, что указатели, в конечном итоге (после серии
разименований), указывают на одну и ту же ячейку (которая
несвязана, то есть, указывает сама на себя) --- эффект применения
правила (4). То же правило применяется и в данных случаях, только
один из указателей уже будет связан (\te указывать на конкретный
объект):

\begin{example}{}{}
?- A = 1, A = B, B = C, 2 = D, write((A, B, C, D)).

1,1,1,2
\end{example}

Здесь также будет применяться правило (3), для того, чтобы C
стало указывать на 1 (C -> B -> A -> 1) .

Правило (4) даёт эффект того, что порядок унификации не важен
(указатели могут уже указывать на ячейки до того, как они получат
значения):

\begin{example}{}{}
?- B = C, A = B, A = 1, 2 = D, write((A, B, C, D)).              

1,1,1,2
\end{example}

Правило 5 даёт возможность обрабатывать ситуацию, когда две
переменные уже связаны:

\begin{example}{}{}
?- A = 1, B = 2, C is B - 1, A = C.

1,2,1
A = 1,
B = 2,
C = 1.
\end{example}

Сравните со следующим примером (похоже на уравнение):

\begin{example}{}{}
?- B = 2, C is B - 1, A = C.

1,2,1
B = 2,
C = A, A = 1.
\end{example}

Результат тот же, но Пролог говорит, что указатели C и A
указывают на одну ячейку

Ещё пример

\begin{example}{}{}
?- A = C, writeln((A, B, C)), B = 2, C is B - 1, writeln((A, B,
  C)).

_G2460,_G2463,_G2460
1,2,1
A = C, C = 1,
B = 2.
\end{example}

Видно, что A и C оказались связаны ещё до того, как один из них
получил значение.

Для полноты картины следует рассмотреть какой-либо отрицательный
пример:

\begin{example}{}{}
?- A = B, A = 1, B = 2.
false.
\end{example}

В чём особенность всех приведённых примеров? В том, что, кроме
wrieln, которые печатают значения переменных в конкретном месте,
все остальные части выражения могут идти в любом порядке. Это
достигается правилами унификации, которые, по сути, делают
унификацию похожей на алгебру.

\section{Перебор вариантов.}

Давайте сделаем следующий шаг в примере \ref{GetDOM}. Для этого
подгрузим библиотечный модуль xpath. Документацию по модулю вы
можете найти здесь
\url{http://www.swi-prolog.org/pldoc/man?predicate=xpath%2F3}.

\begin{example}{Поиск всех тегов a}{a_tags_xpath_sample}
?- [library(xpath)].

?- site(Site), !, http_get(Site, Html, []), xpath(Html, //a, A).

Site = 'www.classicfm.co.uk',
Html = [...],       
A = element(a, [href='#content', shape=rect], ['Skip to Content']) 
;                                                                

Site = 'www.classicfm.co.uk',
Html = [...],       
A = element(a, [id=listen_link, href='http://ukrp.musicradio.com/classicfm/live', class=listen_live, shape=rect], ['Listen']) 
;
      
Site = 'www.classicfm.co.uk',
Html = [...],       
A = element(a, [title='Jamie Crick', href='http://www.classicfm.co.uk/afternoons', shape=rect], ['Jamie Crick'])
;

\end{example}

Данный запрос представляет собой пример недетерминированного
предиката --- количество его ``решений'' зависит от структуры
сайта. В данном случае, мы разбираем страницу нашего первого
сайта (www.classicfm.co.uk) и выделяем все теги <a
..>...</a>. Сам тег унифицируется с переменной A и, как видим,
представляет в Прологе собой структуру element/3 (вообще, все
sgml теги имеют такую структуру). Первый элемент структуры - это
имя тега, в данном случае `a', второй - это уже встречавшийся нам
список, в данном случае, список пар атрибут = значение, и,
наконец, третий аргумент - это список того, что содержится между
<a ...> и <a> (в нашем примере --- это просто текст, который и
представлен в виде атома). 

Наш запрос даёт столько решений, сколько тегов a содержится на
странице, мы заранее это число не знаем (может быть и не одного),
потому этот предикат (выражение) называется недетерминированным.

Простейший недетерминированный предикат можно написать следующим
образом:

\begin{example}{}{}
?- A = a ; A = b.
\end{example}

`;' означает операцию ``или''. Мы говорим ``A равно или a или
b''. При начале выполнения управление идёт по первому пути и A
унифицируется с атомом a. Предикат возвращает управление, но
оставляет, \tn choiсe point --- как-бы оставляет закладку в то
место, в которое желает вернуться. При ответе ';' пользователя
Пролог возвращается в choice point и выбирает другой путь.

Естественно choice points может быть несколько, Пролог делает
несколько закладок:

\begin{example}{}{}
?- (A = 'it will be'; A = 'it will not be'), 
   (B = rain; B = snow).

A = 'it will be',
B = rain 
;
A = 'it will be',
B = snow 
;
A = 'it will not be',
B = rain 
;
A = 'it will not be',
B = snow.
\end{example}

(Так, в первом приближении, можно сэмулировать сайт
\url{gismeteo.ua}).

Они, также, могут быть вложенными:

\begin{example}{}{}
?- (A = 'it will be', (B = rain; B = snow); 
    A = 'it will be fine!').

A = 'it will be',
B = rain 
;
A = 'it will be',
B = snow 
;
A = 'it will be fine!'.
\end{example}

И, наконец, ``сидеть'' в разных предикатах.

\begin{example}{База погоды}{weather_db_sample}
:- module(weather, [weather/1]).

weather('black ice').
weather(X) :- X = storm ; X = fog.
weather(X) :- X = hail ; X = snow ; X = rain.
\end{example}

\begin{example}{}{}
?- A = 'it will be', weather(B) ; 
   A = 'it will be fine!'.

A = 'it will be',
B = 'black ice' ;
A = 'it will be',
B = storm ;
A = 'it will be',
B = fog ;
A = 'it will be',
B = hail ;
A = 'it will be',
B = snow ;
A = 'it will be',
B = rain ;
A = 'it will be fine!'.
\end{example}

Обратите внимание. Во втором и третьем предикате weather мы
используем унификацию с X, однако, в ходе любых запросов первый
элемент базы ведёт себя аналогично другими. База следующего вида
(содержащая те же предикаты в форме исключительно фактов):

\begin{example}{}{}
:- module(weather, [weather/1]).

weather('black ice').
weather(storm).
weather(fog).
weather(hail).
weather(snow).
weather(rain).
\end{example}

Полностью аналогична \ref{weather_db_sample}, так же как и
один-единственный предикат\footnote{На самом деле различие
  имеется в скорости поиска ответа в примере
  \ref{check_wether_sample}, что связано с внутренним механизмом
  индексацией базы по первому аргументу головы }:

\begin{example}{}{}
weather(X) :- 

     X = 'black ice',
   ; X = storm
   ; X = fog
   ; X = hail
   ; X = snow
   ; X = rain.
\end{example}


Иными словами, механизм выбора различных термов по шаблону из
базы оставляет такой же choice point, как и перечисление значений
через `;', а `;', ``спрятанный'' в предикате --- такой же, как и
`;' на самом верхнем уровне. Любой choice point вынуждает Пролог
делать ``закладку'' как, бы вложен он не оказался.

Процесс ``возвращения к закладке'' в Прологе называется
``откатом''. Если вам знаком язык С, то можно сказать, что откат
--- это long jump, но который возвращает не только состояние
потока выполнения, но и состояние унификации к месту последней
закладки.

На слова ``состояние унификации'' следует обратить
внимание. Потому, что это только часть данных Пролога. Мы покажем
это различие.

Но, вначале, продемонстрируем несколько управляющих структур.

\section{Управляющие конструкции Пролога}

Довольно странно, что об управляющих конструкциях мы заговорили
только сейчас. При изложении алгоритмических языков это делается
в начале. Ответ, почему мы так сделали, очевиден --- в Прологе
поток управления --- это то, что управляется логикой. Точнее,
унификацией и откатом.

Рассмотрим модель последовательного выполнения.

\begin{example}{}{}
?- write(' vene'), write(' vidi'), write(' vici').
 vene vidi vici
true.
\end{example}

Внесём модификацию:

\begin{example}{}{}
?- weather(X), format("\n~a:\t", [X]), 

   ( X \= 'black ice',     write(' vene') ), 
   ( X \= storm, X \= fog, write(' vidi') ), 
   ( X \= hail, X \= snow, write(' vici') ).

black ice:      
storm:   vene
fog:     vene
hail:    vene vidi
snow:    vene vidi
rain:    vene vidi vici
X = rain.
\end{example}

\verb|\=| --- это операция, обратная унификации. Она истинна,
когда унификация возвращает false. Вместо \verb|A \= B| можно
писать \verb|\+ (A = B)|, где \verb|\+| --- это логическое
НЕ. format - это предикат форматного вывода, подобный printf в
языке C
(\url{http://www.swi-prolog.org/pldoc/man?predicate=format/2}).
Скобки вокруг пар \verb|(X \= value , action)| употреблены для
наглядности, приоритет оператора `,', формирующего структуру
последовательного выполнения, один и тот же, потому они, по
большому счёту, не нужны.

Давайте разберём, что содержит пример и как он выполняется.

\begin{enumerate}
\item В начале мы берём {\it очередное\/} значение погоды и
  унифицируем его с переменной X, после чего это значение
  печатаем с новой строки, завершая его двоеточием (и
  табуляцией).
\item Если X не равен 'black ice', то делаем действие
  vene. Обратите внимание, X в этом месте уже имеет конкретное
  значение (в противном случае, \verb|\=| бы не отработал, он, в
  отличии от \verb|=| требует связанности обоих аргументов). При
  первой погоде из списка --- black ice (гололёд) наш герой
  ``поскальзывается'' на самом первом действии (унификация X =
  'black ice' --- истина, потому X \verb|\=| 'black ice' вернёт
  false). Оператор последовательного выполнения (,), он же
  оператор логического И, в Прологе работает, как говорят а
  программировании, по короткой схеме --- в случае, если
  очередной аргумент --- false, дальнейшая проверка не
  осуществляется. Если бы мы написали так:

  \begin{example}{}{}
?- weather(X), format("\n~a:", [X]), !,

   ( X \= 'black ice',     write(' vene') ), 
    ...
  \end{example}

  то на этом бы всё и закончилось. Однако наличие choice point
  приводит к тому, что в случае неудачи (fail) вычисления
  логического выражения происходит возврат к ближайшей (по
  истории выполнения) choice point и ``пробуется'' другой вариант
  (если разобраться, то это полностью соответствует законам
  математической логики).
\item Ближайшая choice point находится в предикате weather, и
  предикат унифицирует X со значением storm. Действие vene теперь
  открыто, но на следующей строчке опять происходит fail. Мы
  возвращаемся в модуль weather.
\item fog вычисляется аналогично. hail ``закрывает'' последнее
  действие --- vici, как и snow. И только X = rain удовлетворяет
  всем условиям, потому предикат завершается с единственным
  значением --- rain. 
\item Как ``побочный'' логический эффект, мы решили логическое
  уравнение --- нашли погоду, при которой нашему герою удаётся и
  vene и vidi и vici.
\end{enumerate}

Давайте заставим нашего героя проявить изобретательность. Добавим
альтернативные варианты действий:

\begin{example}{}{}
?- weather(X), format("\n~a:\t", [X]), 

   (  X \= 'black ice' 
   -> write(' vene') 
   ;  write(' skate') 
   ), 

   (  X \= storm, X \= fog 
   -> write(' vidi') 
   ;  write(' grope') 
   ),

   (  X = hail 
   -> write(' pelt with ice')
   ;  X = snow
   -> write(' fight with snow balls')
   ;  write(' vici')
   ),
   fail ; true.
\end{example}

Операция \verb|(If -> Then ; Else)| --- это ветвление. В
принципе, прочитав предыдущий материал, вы можете найти, что она
аналогична 

\verb|( If , Then ; \+ If, Else )|

и вы будете весьма правы\footnote{На самом деле If -> Then ; Else
  аналогична If, !, Then ; Else}. Важной особенностью этой
операции является то, что она не допускает отсутствие части
Else. Вернее, вы можете написать
\verb|( X = snow -> write(' play snowball') )|, но если
\verb|X \= snow|, выражение даст false (и откат). Если вы имеете
в виду действие, которое выполняется только по snow, следует
написать так:

\verb|( X = snow -> write(' play snowball') ; true )|

подчеркнув тем самым, что есть пустой вариант для
\verb|X \= snow| (просто не делать действие), и можно идти
дальше. Также теперь важно обязательно использовать скобки вокруг
(If -> Then ; Else) и двух её редуцированных форм (If -> true ;
Else ), ( If -> Then ; true), потому как приоритет оператора
\verb|->| меньше, чем у (\verb|,|).\footnote{Хорошей практикой
  является всегда заключать логическое ИЛИ и конструкцию If в
  скобки}

Последняя строчка fail ; true - это Прологовский цикл. Смотрите,
что происходит. Если выражение ``дошло'' до конца (не сфейлилось
ни на каком условии), то, в конце его ждёт явно указанный fail
--- предикат, который всегда вычисляется в false. В данном
примере получается как у Владимира Высоцкого: ``вдоль дороги ---
лес густой с Бабами-Ягами, а в конце дороги той --- плаха с
топорами''. Плохо бы пришлось герою, если бы ... если бы не
choice points и финальный true! ``Плаха с топорами'' в виде fail
делает безусловный откат на ближайшую закладку, а когда все
``отложенные варианты жизни'' кончаются, нас ждёт сюрприз --- `;'
в последней строчке (он рассматривает всё предыдущее выражение
как компонент ИЛИ, потому что приоритет , выше, чем ;) создаётся
финальная choice point, который даёт happy end в виде твёрдого
Прологовского true.

fail;true позволил избавиться от недетерминизма, превратив
множественность вариантов в цикл. Это один из способов
избавляться от недетерминизма в Пролог программах (другим
способом является \verb|!|).

Вот результат работы примера:

\begin{example}{}{}
black ice:       skate vidi vici
storm:   vene grope vici
fog:     vene grope vici
hail:    vene vidi pelt with ice
snow:    vene vidi fight with snow balls
rain:    vene vidi vici
true.
\end{example}

Коль скоро мы заговорили о циклах, давайте немного углубим свои
знания в этой области.

Если вы привыкли программировать на C/Java или другом не
логическом языке, то вы, поначалу, можете ощущать дискомфорт от
отсутствия конструкции вроде
\verb|for (int i = 0; i < 10; i++)|. Ну что ж, хотя мы, обычно,
не прибегаем к ней в Прологе (потому что управляемся, чаще
размерностью данных, чем числом 10), однако держите на заметку:

\begin{example}{}{}
?- between(0, 9, I), 
   Square_I is I * I, 
   format("~d^2 = ~d\n", [I, Square_I]), 
   fail; true.

0^2 = 0
1^2 = 1
2^2 = 4
3^2 = 9
4^2 = 16
5^2 = 25
6^2 = 36
7^2 = 49
8^2 = 64
9^2 = 81
\end{example}

Вот ещё:

\begin{example}{Таблица умножения}{mul_tab_sample}
?- between(2, 9, I), nl, 
   between(2, 9, J), 
   Mul is I * J, 
   format("~d x ~d = ~d\n", [I, J, Mul]), 
   fail; true.                           
\end{example}

Как видите, Пролог не так страшен, как о нём пишут в
сухой академической литературе.

Если хотите себя проверить, ответьте на вопрос. Что будет, если в
начале примера \ref{mul_tab_sample} написать \verb|I = J|? А если
тоже самое перед format? А если перед финальным fail? Ответили?
Хорошо. Теперь тот же вопрос для \verb|I < J|.

Вод здесь заковырка. Обязательно попробуйте пример в разных
вариантах. Вы в замешательстве? Читайте дальше!

\section{Highly wanted: регулировщики движения}

Прологовское выражение подобно трассе. Вы задаёте повороты и
препятствия, но не сидите за рулём авто (это, за вас, делает сам
Пролог). Тот, кто делает трассу обязан подумать о разных машинах
и направлениях. Вы должны поставить дорожные знаки, чтобы
ограничить определённые потоки.

Давайте рассмотрим это на примере between/3. Как вы думаете, что
получится, если выполнить:

\begin{example}{}{}
?-  between(1, 4, I), 
    between(2, 3, I), 
    format("~d ", I), 
    fail;true.
\end{example}

Если не уверены, попробуйте. Можете первые две строки поменять
местами. Теперь добавьте отладочную печать:

\begin{example}{}{}
?-  between(1, 4, I), 
    format("<~d> ", I),
    between(2, 3, I), 
    format("~d ", I), 
    fail;true.
\end{example}

Как вы можете заметить, если сделаете пример, поведение between
зависит от того, свободен или связан его третий аргумент. Если он
связан, то предикат делает, собственно, то, что декларируется
названием --- проверяет, что $arg1 <= arg3 <= arg3$. Но, если
свободен, то сам, не дожидаясь особого приглашения, начинает
``подсказывать'' все варианты решения проблемы. Собственно,
последнее свойство и делает возможным построение с его помощью
цикла for (разработчики Пролога --- люди хитрые, они позаботились
о том, чтобы предикат выдавал решения последовательно).

В отличии от between/3, ни </2, ни >/2, ни даже >=/2 и =</2
(операторы ``больше либо равно'' и ``меньше либо равно'') так не
умеют\footnote{если хотите, можете написать свои варианты. Вам
  понадобится предикат op/3 и рекурсия, об этом, как раз, пишут в
  книжках}. То есть, они, по сути, дают только одностороннее
движение аргументов --- на вход (\te, все аргументы должны быть к
моменту вызова предиката связаны). Так ведёт себя подавляющее
большинство предикатов, работающих с числами (тем более, что
предикаты сравнения распространяются не только на целые числа)

Именно поэтому в примере \ref{mul_tab_sample} $I < J$ можно
ставить не раньше второго between.

На самом деле, я спешу вас утешить. К данному моменту мы
продвинулись достаточно глубоко в толщу логического
программирования, и у нас есть весь необходимый багаж знаний,
чтобы приступить к серьёзному анализу наших веб сайтов (из
примера \ref{module_sites_sample}).

\section{Продвижение вглубь интернета}

WWW представляет собой, как вы знаете, паутину. Это значит, если
ползти по одной верёвочке, можно приползти в любую её часть. На
самом деле, ссылки с одного сайта на другой образуют некий
граф. Обычно вы не можете продвинуться достаточно далеко, так как
делаете это в ручном режиме --- читаете страницу, щёлкаете на
одиночные ссылки. (Некто выдвинул гипотезу, что если достаточно
долго кликать по различным, понравившимся вам, ссылкам, то, рано
или поздно, вы оказываетесь в клоаке интернета; очевидно, если
начинать путь с сайтов новостей, вы оказываетесь там гораздо
раньше --- главное, уверенно отвечать, что вам больше 18 лет).

Мы пойдём другим путём. Мы заставим кликать ссылки
Пролог\footnote{Интересно, будет ли при этом результат аналогичен
выдвинутой тем остряком гипотезе?}.

Интересен вопрос о том, как много можно обойти сайтов, если
начать с нашего списка в модуле sites
(\ref{module_sites_sample}).

Давайте попробуем. 

Вполне очевидно, что для того, чтобы начать идти надо сделать
первый шаг. В примере \ref{a_tags_xpath_sample} мы уже занесли
ногу. Давайте уточним, что нас интересует только атрибут href и
распечатаем все ссылки:

\begin{example}{}{}
?- site(Site), !, http_get(Site, Html, []), 
   xpath(Html, //a(@href), Href), writeln(Href),
   fail; true.
\end{example}

Ссылки могут получиться двух типов --- локальные (на тот же сайт)
и глобальные. Нас, в первую очередь, будут интересовать
глобальные ссылки, так как именно они обеспечивают продвижение
``вглубь''. Для того, чтобы их отличать от локальных ссылок,
можно воспользоваться библиотечным модулем работы с URI:

\begin{example}{}{}
?- [library(uri)].

?- site(Site), !, http_get(Site, Html, []), 
   xpath(Html, //a(@href), Href), 
   uri_is_global(Href), writeln(Href), 
   fail ; true.
\end{example}

При этом у вас, как и у меня, может получиться довольно смешанный
список. В нём могут присутствовать ссылки на разные страницы
одного и того же сайта. Можно уменьшить немного количество
информации, заменив ссылки на страницы одной единственной ссылкой
на корень сайта. Воспользуемся предикатом uri_components/2. С его
помощью можно как разобрать URI, так и собрать, в зависимости от
направления потока данных:

\begin{example}{}{}
?- uri_components('http://e.com/file?a=1&b=2#part2', C).

C = uri_components(http, 'e.com', '/file', 'a=1&b=2', part2).

?- uri_components(Url, uri_components(https, 'bank.com', '/deposit', 'sum=3000', 'window2')).

Url = 'https://bank.com/deposit?sum=3000#window2'.
\end{example}

По сути, в первом случае, мы получаем то, что в других языках
называется record (обратите внимание --- её имя совпадает с
именем предиката, в этом нет особого смысла, просто так захотели
разработчики библиотеки, вероятно, для того, чтобы не плодить
новых имён).

Для доступа к структуре uri_components/5 можно было бы
использовать (банальную) унификацию в сочетании с анонимными
переменными:

\begin{example}{}{}
?- uri_components('http://e.com/file?a=1&b=2#part2', C),
   C = uri_components(_, Site, _, _, _).

Site = 'e.com'.
\end{example}

(помните правило (6) унификации \ref{unify_rules}?)

Кстати, мы использовали анонимную переменную `_' --- это особая
переменная, единственная в своём роде. Сколько бы \verb|_| не
встречалась, она всегда означает новую переменную, анонимную
(попробуйте \verb|write((_, _, _)).|) В Прологе она используется,
в зависимости от направления движения --- либо чтобы
проигнорировать результат, либо, чтобы передать в предикат
несвязанную переменную. В данном примере мы скормили ей все
неинтересные части.

Однако, возвращаясь к последнему примеру. Зависимость от арности
и позиционная привязанность давно считаются mauvais ton. Та же
библиотека \verb|uri| предоставляет предикат доступа к структуре:

\begin{example}{Использование uri_data}{uri_data_sample}
?- uri_components('http://e.com/file?a=1&b=2#part2', C),
   uri_data(Field, C, Value), 
   format("uri_data(~a, C, ~q)\n", [Field, Value]), 
   fail ; true.                                                             

uri_data(scheme, C, http)
uri_data(authority, C, 'e.com')
uri_data(path, C, '/file')
uri_data(search, C, 'a=1&b=2')
uri_data(fragment, C, part2)
\end{example}

То есть, как вы поняли, в нашем случае 

\begin{example}{}{}
?- uri_components('http://e.com/file?a=1&b=2#part2', C),
   uri_data(authority, C, Value).                                           

Value = 'e.com'.
\end{example}

Это даёт нам возможность написать следующий предикат:

\begin{example}{}{}
:- module(sites, [site/1, page_link/2]).

...

% page_link(+Page, ?Link_To_Site) is nondet
page_link(Page, Link_To_Site) :-

   http_get(Page, Html, []),
   xpath(Html, //a(@href), Href), 
   uri_is_global(Href), uri_components(Href, Comps), 
   uri_data(scheme, Comps, http), % it counts only http links
   uri_data(authority, Comps, Link_To_Site).
\end{example}

Логический смысл page_link/2 следующий: предикат истенен тогда и
только тогда, когда страница Page содержит ссылку на сайт
Link_To_Site. Допустимые направления движения отмечены в
комментарии. \verb|+Page| означает, что страница должна
подаваться на вход (иными словами, Page должна быть уже связана),
а Link_To_Site допускает любые формы унификации (иными словами,
мы можем давать готовое имя на проверку или получать список
ссылок с помощью одного и того же предиката). Комментарий is
nondet --- это предупреждение программисту о том, что предикат
может оставлять choice point (недетерминированные предикаты
требуют либо циклов либо отсечений; даже если мы подаём оба
аргумента связанными, мы можем получить столько решений true,
сколько раз на странице будет встречена ссылка на Link_To_Site).

Давайте построим на основе page_link ещё один предикат, на этот
раз детерминированный.

\begin{example}{}{}
:- module(sites, [site/1, page_link/2, page_links/2]).

...

% page_links(+Page, -Site_List) is det
page_links(Page, Site_List) :-

  findall(Link, page_link(Page, Link), Link_List),
  sort(Link_List, Site_List).
\end{example}

findall/3 действует по такой схеме. Запускает второй аргумент
столько раз, сколько решений он содержит, на каждом проходе
заново унифицирует свой первый аргумент и составляет список по
результатам всех проходов, который возвращает в третьем
аргументе. sort/2 сортирует полученный список, удаляя все
повторения. \To, на выходе получаем не просто список, а
множество (= список без повторений). Предикат детерминированный и
допускает только одно направление движения (на это указывают
знаки \verb|+| и \verb|-| в комментарии)

\begin{example}{}{}
?- site(Site), !, page_links(Site, Links).

Site = 'www.classicfm.co.uk',
Links = ['123sing.classicfm.com', 'adserver.adtech.de', 'dating.classicfm.co.uk', 'icls.fimc.net', 'moviemusicchart.classicfm.co.uk', 'promo.classicfm.co.uk', 'ukrp.musicradio.com', 'www.classicfm.co.uk', 'www.classicfm.com'|...].                                                                         
\end{example}

В принципе, можно было бы так и оставить, но, для того, чтобы
привести пару дополнительных примеров и дать полезный набор
Пролог-приёмов, давайте избавимся от многоуровневых
доменов. Строго говоря, 123sing.classicfm.com и
moviemusicchart.classicfm.co.uk - это ссылки на один и тот же
сайт.

\section{Большой и нужный пример}

Можно было бы иметь список доменов верхнего уровня (.com, .de,
.co.uk) и сокращать все остальные ссылки до доменов следующего
уровня - classicfm.com, adtech.de, classicfm.co.uk. Но для этого
надо разбить доменное имя на компоненты.

Я не льщу себя надеждой, что вы помните, как это
делается. Но о предикате, который способен это делать я
уже говорил.

Небольшая подсказка:

\begin{example}{}{}
?- concat_atom([www, kogorta, dp, ua], '.', A).
A = 'www.kogorta.dp.ua'.
\end{example}

Подсказка номер 2: \verb|concat_atom(?List, +Separator, ?Atom)|

Итого

\begin{example}{}{}
?- concat_atom(L, '.', 'www.kogorta.dp.ua').

L = [www, kogorta, dp, ua].
\end{example}

Да, он работает в обе стороны. Как и большинство предикатов,
принимающих списки.

Алгоритм решения проблемы я предлагаю следующий


\begin{enumerate}
\item Создаём базу доменов верхнего уровня.
\item Для каждого элемента списка Site_List в начале
  ``откусываем'' домен верхнего уровня, если он присутствует в
  базе.
\item Если домен верхнего уровня в базе отсутствует, то, берём
  хвостовой компонент имени и помещаем его в базу доменов
  верхнего уровня, предупреждая пользователя.
\item От оставшегося имени оставляем только последний компонент и
  заново склеиваем с откусанным хвостом.
\item Заново сортируем список получившихся сайтов, удаляя дубликаты.
\end{enumerate}

Вот таким может быть начальный список высокоуровневых доменов:

\begin{example}{}{}
:- module(sites, [top_level/1, ....]).

:- dynamic top_level/1.

top_level('.com').
top_level('.net').
top_level('.org').
top_level('.info').
top_level('.co.uk').
top_level('.dp.ua').

....
\end{example}

\verb|:- dynamic| говорит о том, что предикат top_level/1
будет дополняться программой в процессе выполнения.

Откусывание хвоста будем производить с помощью тоже уже
известного нам atom_concat/3.

atom_concat/3, предикат конкатенации атомов --- это улица с
четырёхсторонним движением. Его ``дорожные знаки'':
\verb|atom_concat(?A1, ?A2, ?A3)|, но есть ещё ``регулировщик'':
хотя бы один аргумент должен быть связан:

\begin{bigexample}{}{}
?- atom_concat('It is Prolog, ', 'baby', X).
X = 'It is Prolog, baby'.

?- atom_concat('Yes, I am not ', X, 'Yes, I am not A wimp').
X = 'A wimp'.

?- atom_concat(X, variable, 'has deal with that variable').
X = 'has deal with that '.

?- atom_concat('Do you know ', 'Prolog baby?', 'Do you know me?').
false.
 
?- atom_concat('Do you know ', X, 'I know Prolog ').
false.

?- atom_concat(X, X, 'But I know Prolog!').
false. % Oops

?- atom_concat(X, Y, 'Really I know it?'), 
   format("~a * ~a\n", [X, Y]),                                             
   fail; writeln('shure!').                                                

 * Really I know it?
R * eally I know it?
Re * ally I know it?
Rea * lly I know it?
Real * ly I know it?
Reall * y I know it?
Really *  I know it?
Really  * I know it?
Really I *  know it?
Really I  * know it?
Really I k * now it?
Really I kn * ow it?
Really I kno * w it?
Really I know *  it?
Really I know  * it?
Really I know i * t?
Really I know it * ?
Really I know it? * 
shure!

?- atom_concat(X, X, 'more more ').
X = 'more '. 
% Dude

?- atom_concat(Ido, Ido, Ido).
ERROR: atom_concat/3: Arguments are not sufficiently instantiated
\end{bigexample}

Для ``откусывания'' хвоста нам нужно использовать его в форме

\verb|atom_concat(-A1, +A2, +A3)|:

\begin{example}{}{}
?- atom_concat(X, '.org', 'www.swi-prolog.org').

X = 'www.swi-prolog'.
\end{example}

Этап, который называется ``откусываем хвостовой компонент имени и
помещаем его в базу доменов верхнего уровня, предупреждая
пользователя'' логически разбивается на 3 части: определение
потенциального домена верхнего уровня, помещение домена в базу и
предупреждение пользователя.

Первое действие можно запрограммировать, основываясь на таком
эвристическом правиле: если домен первого уровня содержит больше
2-х букв, то считать его верхним, иначе, если домен второго низкого
уровня содержит не более 3-х букв, то считать домен 2-го уровня
верхним, иначе считать верхним уровнем только 1-ый:

\begin{example}{Эвристическое определение домена верхнего уровня}{top_level2}
top_level(Domain, Top_Domain) :-

  concat_atom(Parts_R, '.', Domain),
  reverse(Parts_R, [First, Second|_]),
  (  atom_length(First, First_Len), First_Len > 2
  -> Top = [First]
  ;  atom_length(Second, Second_Len), Second_Len =< 3
  -> Top = [First, Second]
  ;  Top = [First]
  ),
  reverse(Top, Top_R),
  concat_atom([''|Top_R], '.', Top_Domain).
\end{example}

Здесь унификация второго аргумента с выражением
\verb|[First, Second|_]| это аналог:

\begin{example}{}{}
?- [a, b, c] = [Head|Tail].

Head = a,
Tail = [b, c].
\end{example}

(Пролог очень любит лакомиться списками, в частности, откусывать
от них голову. В примере \ref{top_level2} мы лакомимся также
шеей, зато всё остальное скармливаем анонимной
переменной. Запомните --- Пролог всегда ест списки с головы!
Потому мы его переворачиваем два раза --- до и после трапезы).

Вопросы любознательным --- что будет, если Domain содержит только
один компонент ($Domain = com$)? Зачем мы приставляем ``пустую
голову'' к списку в последнем concat_atom?

\begin{example}{}{}
?- top_level('www.example.com', T).                                         
T = '.com'.

?- top_level('example.com.ua', T).                                          
T = '.com.ua'.

?- top_level('www.example.co.uk', T).                                       
T = '.co.uk'.
\end{example}

Для добавление предиката в базу Пролога используется предикат
assertz. Буква `z' говорит о том, что мы хотим добавить в конец
базы (база Пролога упорядочена).

\begin{example}{}{}
?- top_level('.name').
false.

?- assertz(top_level('.name')).

?- top_level('.name').
true.
\end{example}

Предикаты, добавленные в базу будут там, пока мы не выйдем из
Пролога. Для удаления ошибочных записей делайте так:

\begin{example}{}{}
?- retractall(top_level('.name')).
\end{example}

(retractall удаляет все записи, унифицирующиеся с
аргументов. Если вы добавили .name два раза, то retractall
удалит оба вхождения, в отличии от retract/1).

\begin{example}{}{}
?- top_level('.name').
false.

?- assertz(top_level('.name')).

?- assertz(top_level('.name')).

?- top_level('.name').
true ;
true.
\end{example}

Обычно, дублирование фактов, это не то, что мы ожидаем.
Потому лучше лишний раз от этого застраховываться:

\begin{example}{}{}
?- A = top_level('.name'), \+ A -> assertz(A).
A = top_level('.name').

?- A = top_level('.name'), \+ A -> assertz(A).
false.
\end{example}

(Вспомните раздел \ref{terms}. Мы там говорили о том, что
предикат или структура --- это в зависимости от контекста. Данный
пример показывает, как можно в одном выражении использовать
top_level/2 в двух контекстах. Если вас всё ещё смущает выражение
\verb|\+ A|, то попробуйте следующий пример:

\begin{example}{}{}
?- X = 'Hello again!',
   Y = writeln(X), Z = writeln(Y), 
   Y, Z.
\end{example}

Итак, мы умеем проверить наличие факта в базе и добавить его,
если он отсутствует.

Нам, для реализации задуманного, осталась часть, которая будет
проходиться по списку и менять имена.

Для начала предлагаю оформить операцию замены одиночного имени в
отдельный предикат:

\begin{example}{}{}
% domain_site(+Domain, ?Site) is det
domain_site(Domain, Site) :-

  (
      % The Top domain is already present in top_level/1
      top_level(Top)
  ;
      % There is not known top level for Domain
      % Try determine it by top_level/2
      top_level(Domain, Top),
      format("Add the new top level: [~a]\n", Top),
      assertz(top_level(Top)),
   ),

   atom_concat(Subdomain, Top, Domain), !,
   concat_atom(Subdomain_R, '.', Subdomain),
   reverse(Subdomain_R, [Site_Part|_]),
   atom_concat(Site_Part, Top, Site).
\end{example}

Предикат domain_site состоит из двух частей. Первая часть
генерирует домены верхнего уровня. Сначала идёт перебор базы
top_level/1 и, если ничего не нашли, выполняется вторая часть ИЛИ
--- ``выкусывание'' домена верхнего уровня с помощью top_level/2
и добавление его в базу.

Вторая часть начинается с atom_concat/3. Она, одновременно,
тестирует, что Domain заканчивается на Top и, в случае успеха,
унифицирует Subdomain с начальной частью. Как только это удаётся,
сразу выполняется отсечение (!). Срабатывание отсечения
заключается в том, что после перехода потока управления через
отсечение все закладки, видимые в данном предикате, будут сразу
вытащены\footnote{Видимые в предикате означает, что для choice
  point, поставленной не в процессе выполнения предиката и всех
  его вложенных вызовов (например, choice point предиката,
  вызвавшего domain_site/2) закладка сохранится.}. Отсечение
здесь необходимо, чтобы больше не происходил возврат в
генераторную часть (fail может быть также в предикате, который
нас вызовет, а правила хорошего тона программирования на Прологе
обязывают разработчика предиката никогда ``не подсовывать
свинью'' тому, кто будет нас вызывать. ``Не подсовывать свинью''
--- это значит не оставлять бессмысленных choice points, а тем
более, нарушать конвенкцию is det, объявленную в
комментарии. Иными словами --- всегда следите за возможными
choice points --- восклицательный знак вам в руки!)

Внимательный читатель может сказать, что предикат сделан не очень
оптимально. Действительно, зачем генерировать все возможные
варианты, а потом их проверять. Это равносильно написанию:

\begin{example}{}{}
?- between(1, 1000, X),
   between(1, 1000, Y),
   between(1, 1000, Z),
   Z2 is Z * Z,
   Z2 =:= X * X + Y * Y,
   format("~d^2 + ~d^2 = ~d^2\n", [X, Y, Z]),
   fail ; true.
\end{example}

(\verb|=:=| - это арифметическое равенство, не путать с \verb|=|
--- унификацией).

То есть работает, но большую часть времени тратит в пустую
(сравните по скорости, хотя бы с)

\begin{example}{}{}
?- between(1, 1000, Z),
   Z2 is Z * Z,
   Max_X is floor(sqrt(Z2)),
   between(1, Max_X, X),
   Y2 is Z2 - X * X,
   Y is round(sqrt(Y2)), Y2 =:= Y * Y, % test whether Y2 is Y^2
   format("~d^2 + ~d^2 = ~d^2\n", [X, Y, Z]),
   fail ; true.
\end{example}

(Если вы до сих пор считаете, что оптимизация --- это потеря
времени, выполните оба примера)\footnote{Вот тут есть корень
  проблем горе-программистов. То, что на Прологе можно написать
  выражение с декларативной семантикой не означает, что не надо
  думать о производительности}.

Потому, давайте, не откладывая оптимизацию в долгий ящик, сразу
попробуем писать эффективно\footnote{хотя бы для того, чтобы нас
  не считали горе-программистами}:

\begin{example}{}{}
% domain_site(+Domain, ?Site) is det
domain_site(Domain, Site) :-

  (
      % The Top domain is confirm our rules and 
      % is already present in top_level/1
      top_level(Domain, Top),
      top_level(Top)
  ;
      % May be it is an exception from top_level/2 rule
      top_level(Top)
  ;
      % There is not known top level for Domain
      % Try determine it by top_level/2
      top_level(Domain, Top),
      format("\nAdd the new top level: [~a]", Top),
      assertz(top_level(Top))
   ),

   atom_concat(Subdomain, Top, Domain), !,
   concat_atom(Subdomain_R, '.', Subdomain),
   reverse(Subdomain_R, [Site_Part|_]),
   atom_concat(Site_Part, Top, Site).
\end{example}

Мы сразу попытались использовать нашу эвристику, чтобы не вести
полный перебор. Если не угадали --- будем перебирать
всё. Заметьте, однако, что во втором случае top_level/1 просмотрит
тот домен, который уже просматривался в первом --- choice point
--- это вещь очень статическая, она не мигрирует между двумя
вызовами одного и того же предиката (вспомните long jump). Однако
данная потеря не значительная.

Ну что, по-сути предикат обработки одного элемента списка у нас
есть. Для того, чтобы, как сейчас принято умно выражаться,
``масштабировать'' наш алгоритм, достаточно познакомиться с
операцией maplist (она имеет арность от 2 и выше, по количеству
обрабатываемых списков - 1). Нам, для данного случая, подойдёт
maplist/2:

\begin{example}{}{}
?- maplist(domain_site, 
           ['www3.ibm.com', 'www.kogorta.dp.ua',
             'farnell.co.uk'], L).

L = ['ibm.com', 'kogorta.dp.ua', 'farnell.co.uk'].
\end{example}

Итак, мы добрались до финального примера раздела!

\begin{example}{}{}
?- site(Site), !,  % Get our favorit site
   page_links(Site, Links), % Find all links from it
   maplist(domain_site, Links, Sites_Rep), % Domains to sites cancellation
   sort(Sites_Rep, Sites). % Remove all dups

Add the new top level: [.de]

Site = 'www.classicfm.co.uk',

Links = ['123sing.classicfm.com', 'adserver.adtech.de',
  'dating.classicfm.co .uk', 'icls.fimc.net',
  'moviemusicchart.classicfm.co.uk', 'promo.classicfm.c o.uk',
  'ukrp.musicradio.com', 'www.classicfm.co.uk',
  'www.classicfm.com'|...],                                                                        
 
Sites_Rep = ['classicfm.com', 'adtech.de', 'classicfm.co.uk',
  'fimc.net', 'c lassicfm.co.uk', 'classicfm.co.uk',
  'musicradio.com', 'classicfm.co.uk', 'cl assicfm.com'|...],                                                        
 
Sites = ['adtech.de', 'classicfm.co.uk', 'classicfm.com',
  'fimc.net', 'music radio.com', 'omniture.com'].                                               
\end{example}

Последняя из распечатанных переменных, Sites, содержит как раз
то, что мы искали.


\end{document}
