\documentclass[a4paper]{book}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\selectlanguage{russian}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{underscore}
%\usepackage{sectsty}
%\usepackage[normalem]{ulem}
%\usepackage{indentfirst}
%\usepackage{amsfonts}
%\usepackage{fancyhdr}
%\pagestyle{fancy}

\def\tn{т.\thinspace н.}
\def\td{т.\thinspace д.}
\def\tp{т.\thinspace п.}
\def\to{т.\thinspace о.}
\def\To{Т.\thinspace о.}
\def\te{т.\thinspace е.}
\def\Te{Т.\thinspace е.}
\def\ur{Uranium}
\def\na{named\_arg*}

\lstnewenvironment{example}[2]%
   {%
    \minipage[t]{0.9\linewidth}%
    \lstset{language=Prolog, frame=single, breaklines=true,%
            breakatwhitespace=true,%
            basicstyle=\small,%
            frameround=fttt,frame=trBL,%
            caption={#1},label={#2}}%
   }%
   {\endminipage\smallskip}

\lstnewenvironment{bigexample}[2]%
   {%
    \lstset{language=Prolog, frame=single, breaklines=true,%
            breakatwhitespace=true,%
            basicstyle=\small,%
            xrightmargin=0.05\linewidth,%
            xleftmargin=0.05\linewidth,%
            frameround=fttt,frame=trBL,%
            caption={#1},label={#2}}%
   }%
   {\smallskip}

\lstnewenvironment{genexample}[2]%
   {%
    \minipage[t]{0.9\linewidth}%
    \lstset{frame=single, breaklines=true,%
            breakatwhitespace=true,%
            basicstyle=\small,%
            frameround=fttt,frame=trBL,%
            caption={#1},label={#2}}%
   }%
   {\endminipage\smallskip}

\begin{document}
\title{{\bf\ur}\\ \medskip  Пролог-библиотека для автоматизации
  тестирования ПО}
\author{Сергей Лодягин\\ \texttt{lodyagin@gmail.com}}
\date{\today}
\maketitle

\chapter{Введение в \ur-автоматизацию}

Разработка программного обеспечения всегда являлась отраслью, где
инновации часто рождались и умирали в рамках жизни одного
проекта. Но методики, которые сегодня можно назвать
классическими, проходили проверку временем и совершенствовались
десятилетиями. Они давали начала различным
технологиям. Технология позволяла применять отлаженную схему,
группу методик при разработке различных проектов одной группой
разработчиков. Некоторые методики стоят ещё выше технологий,
например, методики тестирования программы или анализа алгоритмов
и являются универсальными.

В последние 10 лет в программировании наметилась тенденция
оформления различных принципов разработки и оформление их как
готовых решений. Например, семейство методик X. Даже программные
продукты, сопровождающие разработку и призванные быть гибким
инструментом позиционируют себя как относящиеся к тому или иному
пакету. И когда вам надо средство тестирования X вам надо и
система учётов дефектов X, и коммуникация X и \td, вплоть до
готовых групп разработчиков X со специального вида X-досками и
X-картами.  Зачастую тоже относится и к языкам программирования,
выбор которых предопределён существующей модой если не
предписаниями гуру от всепоглощающей методики.

Данное положение, являющееся сейчас едва ли не доминирующем во
всей отрасли, создаёт благоприятную почву для возвращения к
проверенным старым технологиям, и, если удаётся такую технологию
пустить в плавание по новому руслу, то зачастую может оказаться,
что добротные суда легко обходят наскоро сколоченные новые
посудины (хотя бы потому, что могут ходить как по так и против
течения).

Одной из таких проверенных временем технологий является язык
Пролог, разработанный французом Аланом Колмерау (Alain Colmeraue)
в 1972 г.

Данная книга является, с одной стороны руководством по системе
тестирования \ur, которая написана на языке Пролог, а с другой
стороны демонстрацией того, как можно использовать проработанные
наукой теории (логику первого порядка, на принципах которой
построен сам язык Пролог) при решении реальных бизнес задач. В
качестве примера выбрана довольно распростанённая и насущного
среди (мелких) компаний задача тестирования интернет-магазина.

\section{Учебный объект}

В качестве примера выбран магазин
\url{http://all-for-skin-beauty.com}, созданный советскими
иммигрантами. Магазин продаёт различные средства по уходу за
кожей и публикует статьи по той же тематике.

Структуру магазина можно изобразить следующей диаграммой.

Часть выше ватерлинии доступна покупателю, ниже - работникам
магазина. Поскольку магазин является роботом, он являет собой
любопытный экземпляр для тестирования - мы можем совершать
виртуальные заходы и наборы корзин и, если договоримся с
администрацией - даже виртуальные покупки виртуальными деньгами
(главное, не мешать основной массе покупателей, создавая высокую
нагрузку на сервер).


\section{Постановка задачи тестирования в современных условиях. 
         Связанные задачи}

Нет более игнорируемой составляющей работ по тестированию равно
как и вообще, работ по обеспечению качества, чем определение
критериев качества, которые желает получить заказчик. Зачастую
заказчик не может сформулировать тот уровень, который его
удовлетворит, полагая что любая ошибка в программе должна быть
найдена и исправлена, и чем скорее, тем лучше. Менеджеры по
обеспечению качества всегда находятся в сложном положении
партизанского отряда, который должен очень скромными ресурсами (и
чем сложнее становятся проекты, тем эти ресурсы кажутся более
скромными менеджеру качества) сделать прорыв в существующем
положении вещей и если не достигнуть новой отметки качества, то
хотя бы помочь удержаться компании на старом рубеже. Положение
усугубляется ещё и тем, что, как правило, группа по обеспечению
качества (англ. QA - Quality Assurance) имеет дело с уже идущим
процессом, поскольку общепринятой практикой, увы, является
исключение специалиста по качеству из процесса принятия решений о
составе следующего релиза. Итак, мы постоянно имеем очередной
релиз с каким-то временем, отпущенным на разработку и
тестирование (профессионалы всегда отводят время на тестирование)
однако критерий качества, тот базовый вектор, который, в конечном
итоге, является наиболее влияющим на объём требуемых ресурсов,
крайне редко бывает определён как по модулю так и по
направлению. Если говорить о стратегии поиска дефектов, то мы
имеем задачу оптимизации - надо достигнуть максимума в некоей
суммарной критичности всех найденных дефектов за ограниченное
время. Неформальная постановка задачи (отсутсвие формулировки
критерия качества приводит, в том числе, к невозможности
определить критичности ошибки) заставляет подходить к задаче
творчески.

При таком подходе уместно сравнить поиск дефектов в программе с
охотой на диких животных. Мы вправе использовать разные районы
поиска, методы, приёмы и \tp, имея перед собой цель - настрелять
дичи разной, преимущественно побольше и покрупнее.

И первое, что для этого необходимо из чисто технических
соображений (опыт и интуиция - это главное, но мы не
рассматриваем) - умение выслеживать дичь и с какой-то долей
вероятности находить по карте места её возможного обитания.  Для
решения предполагаемой задачи надо вооружится планом местности -
для QA это прежде всего требования к программе (которые и
позволяют понять, какое поведение является правильным, а какое -
ошибочным). Всё, что было сказано о критерии качества часто, увы,
относится и к требованиям - они даже если есть, то часто
неформальны и, также часто, противоречивы. В данной статье мы не
будем касаться методики групповой загонки дичи ``всей деревней'',
a будем исходит из предположения, что план местности должен
быть составлен до начала работ самой группой качества.

При этом мы будем формулировать требования формально - на языке
математики. Хотя вопрос об эффективности такой формулировки на
практике достаточно спорный для проектов сроком на месяц,
качественный план местности для регулярных вылазок в ходе
длительного проекта, который, к тому же, непрерывно уточняется -
это может быть одной из творческих находок менеджера по качеству,
которая может принести, а может и не принести сразу ощутимый
результат, но без попытки наведения порядка даже в одной, пусть
малой (но очень важной) области менеджер по качеству не сможет
сказать, что это качество присутсвует, хотя бы в зародыше, что,
рано или поздно, деморализует всю группу.

\section{Кровные деньги и математика}

Чтобы преуспеть в применении формальных методик их надо
использовать там, где предположительный эффект самый
максимальный. Для владельца магазина главное - доход и
рейтинг. Потому, попробуем предположить, глядя на магазин
\url{http://all-for-skin-beauty.com}, что может подпортить доход
и рейтинг, имея в виду, конечно, дефекты робота-магазина, как
технического устройства. Поскольку, как уже было сказано, вопрос
отыскания дичи (дефектов) творческий, автор статьи вправе выбрать
критерии на собственную удачу. Вот они

\begin{enumerate}
\item На экране должно быть как можно больше товара, который
потенциальный покупатель захочет купить.
\item Покупка должна быть лёгкой.
\begin{enumerate}
\item Не более одного клика, чтобы перейти на страницу товара из
любого места в магазине.
\item Минимум кликов для совершения покупки.
\item Отобранный в карзину товар не должен теряться в ходе
переходов.
\end{enumerate}
\item Навигация по магазину не должна содержать грубых ошибок.
\begin{enumerate}
\item По всем ссылкам должен быть рабочий переход.
\item Всегда должна быть возможность вернуться на посещённую ранее
страницу только по ссылкам на экране.
\item Не должно быть недостижимых страниц.
\end{enumerate}
\end{enumerate}

Для учебного примера более, чем достаточно. Давайте перейдём к
практике и начнём с формализации чего-то из списка
сформулированных на удачу требований (а требования,
сформулированные на удачу лучше, чем отсутствие требований
вообще).

\section{Карта навигации}

Беглый взгляд на список требований для тестирования говорит нам,
что требования 2.1-2.2, 3 опираются на понятие навигации. Давайте
формализуем само понятие, и у нас появится возможность
формализовать требование (далее автор предполагает, что читатель
знаком с языком Пролог или хотя бы ознакомился с содержанием
соответствующих глав рекомендуемой книги
(И. Братко. Программирование на языке Пролог для исуственного
интеллекта). И хотя, при переводе некоторых изданий этой книги,
имена предикатов были переведены на русский язык, мы будем
называть предикаты по-английски, чтобы иметь возможность отдать
текст непосредственно транслятору без дополнительных
преобразований (которые никогда не бывают свободны от ошибок, а
мы, в данный момент, работаем над эталоном и олицетворяем собой
палату мер и весов).

Введём отношение contains\_link(Src\_Page, Dst\_Page),
означающее, что Src\_Page содержит ссылку на Dst\_Page. В
принципе, вся навигация содержится в одном отношении. В
дальнейшем его можно будет детализировать, разделив ссылки на
видимые, невидимые, ссылки-картинки и \td, но пока можно начать
и с общего случая. Стоит подчеркнуть, что введённое отношение
является несимметричным и не означает, что Dst\_Page содержит
ссылку на Src\_Page. Нам надо ещё одно соотношение, которое будет
говорить о достижимости страницы A со страницы B путём серии из N
кликов:

\begin{example}{click\_distance}{click_distance}
% click_distance(A, B, N).

click_distance(A, A, 0) :- !.

click_distance(A, B, 1) :- contains_link(A, B), !.

click_distance(A, B, N) :-

                  contains_link(A, C),
                  click_distance(C, B, N1),
                  N is N1 + 1.
\end{example}

(! означает, что при применении правила другие ванианты уже
рассматриваться не будут).

Ввиду того, что данная программа на Прологе представляет собой
поиск пути на графе, а на графе может быть много путей из A в B,
соотношение может давать много решений (по одному на каждый
вызов) либо не одного - если страница не достижима.

Сразу же это наталкивает нас на мысль о формальной формулировке
требования 3.3.

\begin{example}{req3\_3}{}
req3_3 :- \+ (page(A), page(B), \+ click_distance(A, B, _))
\end{example}

Предикат page/1 (так принято ссылаться предикаты в прологе - имя
/ арность) говорит о наличии страницы в магазине (априорные
данные), а \verb|\+| - это отрицание (в ранних версиях пролога
для этого использовалось слово not, которое, хоть и
поддерживается многими реализациями, однако не вошло в ISO
стандарт языка).

Теперь не сложно понять смысл написанного выражение на языке
математики: req3\_3 истина тогда, когда не существует таких двух
страниц магазина A и B, что между ними не возможен переход
(\verb|\_| означает игнорирование переменной, \te, в данном
требовании для нас не важно сколько кликов потребуется, хотя,
очевидно, на практике, лучше уточнять это на уровне самого
требования).

Казалось бы что ещё нужно (думает математик) - загнали выражение
в Пролог - клац - и проверили требование.

Инженер же озадачится вопросом "а откуда взять предикаты-факты
page/1 и contains\_link/2". И это будет правильный
вопрос. Инженер по качеству дополнит вопрос "а как взять эти
предикаты таким образом, чтобы они сами по себе не содержали
ошибку, исключив человеческий фактор при их вводе в систему". И
это будет очень правильный вопрос, потому как едва ли наш метод
бы имел смысл, если бы мы должны были, сформулировав требования
формально, вводить факты для его проверки в рукопашную.

И вот тут мы и начинаем наше основное повествование.  Давайте
поручим сбор фактов самому Прологу! Если одни люди смогли
написать робот для продажи косметики, то другие люди (скажу по
секрету - те же самые) смогли написать робот для автоматического
сбора информации о поведенческих свойствах автоматических систем,
необходимой для тестирования широкого класса задач.


\chapter{Обзор библиотеки \ur}

Пролог-библиотека \ur (\url{http://uranium-test.sourceforge.net})
является свободной библиотекой с открытым исходным кодом, которая
защищена лицензией LGPL - она даёт права модифицировать или
каким-либо другим образом использовать исходный код, с тем
ограничением, что всеми доработками самой библиотеки необходимо
делиться с разработчиками, но использоваться может она в любых
проектах - как открытых, так и закрытых.

После скачивания исходного кода создаётся каталог uranium-test, в
котором основное пространство занимает подкаталог prolog. Сейчас
мы рассмотрим структуру этого каталога:

\begin{verbatim}
action
db
dict
Examples
html
lib
logging
parser
state
tc_support
\end{verbatim}

Это и есть библиотека \ur, но не в чистом виде, а смешанная с
кодом примеров. Давайте рассмотрим подробно структуру библиотеки
и отделим её от демонстрационного кода (который предназначен для
замены кодом пользователя).

\section{Каталог lib}

Это фундамент. Содержит базовые пакеты.

\begin{description} 
\item ur\_objects.pl данный пакет реализует концепцию
  объектов, которой будет посвящена глава \ref{ur_objects}.
\item ur\_recorded\_db.pl объектная база данных, которая
  будет рассмотрена в главе \ref{ur_recorded_db}.
\end{description}

\section{Каталог logging}

Гибкое логирование --- важная составная часть системы автотестов.

\begin{description}
\item logging.pl содержит базовые предикаты, см. главу
  \ref{logging}.
\end{description}

\chapter{Пролог и объекты}
\label{ur_objects}

\section{Концепция объектов в \ur}
Считается, что объектно-ориентированное программирование является
альтернативой логическому/функциональному (или наоборот). Авторы
\ur{} придерживаются другого взгляда - эти две методологии
дополняют друг друга. Точнее, объектно-ориентированное
программирование может быть реализовано на базе логического и
являться его расширением. Подобное расширение, чисто
теоретически, может давать спорные преимущества, однако, мы
убедились на практике, что подобным образом удобно описывать
аспекты тестируемых систем, в составе которых мы выделяем
``объекты''. 

При этом, с точки зрения Пролога, объект - это просто терм
заданной арности. Мы используем особый суффикс для того, чтобы
отличать термы - объекты от обычных термов. Например, когда мы
пишем patient\_v то имеем в виду объект. 

Отличие объектов от прологовских термов состоит в том, что один
объект может быть пронаследован от другого объекта. При этом
арность объекта-наследника будет больше или равна арности
объекта-родителя. Это затрудняет обращение к полям терма обычным,
прологовским методом, потому что смысл объектно-ориентированного
подхода заключается в том, чтобы оперировать как с родителем, так
и с любым его потомком посредством одних и тех же операций.

Рассмотрим следующий пример.

Создадим файл man\_v.pl со следующим содержимым:

\begin{example}{man\_v object definition}{man_v}
:- module (man_v, []).

new_class(man_v, object_v, [sex, name, surname, weight, height]).
\end{example}

Следует обратить внимание на несколько правил:

\begin{enumerate}
\item Имя объекта, как уже было сказано, всегда должно заканчиваться
на ``\_v''. 
\item В каждом файле допустимо объявлять один или несколько
объектов. Во втором случае все объекты без одного должны являться
потомками одного объекта, тоже объявленном в этом
файле. Объявление одного объекта в файле является более
предпочтительным.
\item Имя файла должно совпадать с именем единственного объекта или
``старшего'' объекта файла (плюс расширение ``.pl'').
\item В файле должен быть объявлен модуль, имя которого совпадает с
именем старшего объекта.
\item Список экспортируемых из модуля предикатов, как правило,
оставляют пустым, потому что для подгрузки объектов используется
динамический механизм (файлы-описания объектов загружаются по
мере требования данных объектов в программе).
\item Сам объект объявляется с помощью предикатов-фактов
new\_class/3 или new\_class/4. Первая позиция даёт имя новому
объекту, вторая - указывает имя объекта-предка, третья содержит
список полей и, опционально, их тип (см. далее), четвёртая
(необязательная) - задаёт список полей, формирующих ключ, при
записи объекта в объектную базу \ur (см. далее).
\end{enumerate}

Для того, чтобы динамическая система подгрузки \ur{} могла
обнаружить наш объект, его надо разместить в один из подкаталогов
ниже \verb|uranium-test/prolog| на глубине вложенности не более 5
(точную максимальную глубину можно изменить в коде, благо он
открыт). 

Для работы с объектами необходимо загрузить модуль ur\_objects:

\begin{example}{}{}
[library(ur_objects)].
\end{example}

После успешной загрузки можно создать нового человека:

\begin{example}{}{}
?- obj_construct(man_v, [name], ['Tom'], Man1).
% Examples/man_v.pl compiled into man_v 0.00 sec, 1,592 bytes
% lib/object_v.pl compiled into object_v 0.00 sec, 2,272 bytes
Man1 = man_v(_G33, 'Tom', _G35, _G36, _G37).
\end{example}

Предикат object\_construct имеет две формы - /4 и /5. Мы будем
рассматривать здесь исключительно первую, интересующиеся всеми
подробностями могут посмотреть документацию (постоянный адрес
документации в web - ...).

Первым параметром идёт имя объекта. Вторым - список полей,
которые мы хотим задать при его создании (попробуйте задать
пустой список в качестве упражнения). Третьим - значения
полей. При этом количество элементов в первом списке должно
совпадать с количеством элементов во втором, в противном случае
предикат вычислится в значение false. Последним параметром идёт
всегда имя переменной, в которую и будет помещён созданный
объект. 

Строки, начинающиеся с ``\%'' - это сообщение пролог-системы. В
данном случае на них стоит остановиться. Первое сообщение
информирует нас о загрузке нового модуля man\_v (я разместил его
в каталоге Examples) а второе - модуля object\_v, от которого
пронаследован man\_v. При дальнейшем использовании объектов они
появляться уже не будут (если вы поменяли объект, то его
определение надо будет перегрузить принудительно с помощью
предиката ...).

В результате Пролог присвоил значение переменной Man1 и
проинициализировал заданные при конструировании поля. Остальные
поля оказались не связанные. Коль скоро для Пролога объект ничем
не отличается от терма, то можно было бы использовать обычный
позиционный синтаксис для задания, например, веса и роста новому
объекту

\begin{example}{}{}
?- obj_construct(man_v, [name], ['Tom'], Man1), 
   man_v(_, _, _, 3.9, 54) = Man1.

Man1 = man_v(_G3601, 'Tom', _G3603, 3.9, 54).
\end{example}

\section{Доступ к полям объекта}

Однако этот метод, как уже говорилось, не проходит для объектов
по следующим причинам

\begin{enumerate}
\item В процессе моделирования мы можем добавлять поля к объекту и
позиции будут смещены и арность поменяется.
\item Мы не можем использовать данный метод с потомками, у них будет
другой функтор и арность.
\end{enumerate}

Поэтому для доступа к полям объекта {\itвсегда\/} используются имена
полей. Иными словами, верхний пример нужно переписать таким
образом:

\begin{example}{}{}
?- obj_construct(man_v, [name], ['Tom'], Man1), 
   obj_field(Man1, weight, 3.9), 
   obj_field(Man1, height, 54).

Man1 = man_v(_G3767, 'Tom', _G3769, 3.9, 54).
\end{example}

Следует подчеркнуть, что предикат obj\_field не устанавливает
значение поля, а связывает его в терминах пролога, например

\begin{example}{}{}
?- obj_construct(man_v, [name], ['Mars'], Man1), 
   obj_field(Man1, name, Name).

Man1 = man_v(_G3739, 'Mars', _G3741, _G3742, _G3743),
Name = 'Mars'.
\end{example}
(чтение поля имени)

\begin{example}{}{}
?- obj_construct(man_v, [name], ['Mars'], Man1), 
   obj_field(Man1, name, Name), 
   obj_field(Man1, surname, Name).

Man1 = man_v(_G3776, 'Mars', 'Mars', _G3779, _G3780),
Name = 'Mars'.
\end{example}
(превращение имени в фамилию)

и даже

\begin{example}{}{}
?- obj_construct(man_v, [name], ['Robert'], Man1), 
   obj_construct(man_v, [name], ['Clara'], Man2), 
   obj_field(Man1, surname, Surname), 
   obj_field(Man2, surname, Surname), 
   obj_field(Man1, surname, 'Schumann').

Man1 = man_v(_G3876, 'Robert', 'Schumann', _G3879, _G3880),
Man2 = man_v(_G3916, 'Clara', 'Schumann', _G3919, _G3920),
Surname = 'Schumann'.
\end{example}

(после второго obj\_field фамилии двух людей (здесь Man
использовалось в широком значении ``человек'') стали связанными,
и выбор фамилии для Man1 тут же задал фамилию Man2 (очевидно,
здесь мы смоделировали, в первом приближении, случай женитьбы
Роберта Шумана и Клары Вик. К этому примеру мы будем ещё
неоднократно возвращаться).

Забегая немного вперёд, скажем, что в \ur{} существует целое
семейство предикатов для унификации полей объектов по имени. Все
предикаты данного семейства содержат подстроку
named\_arg. Например, есть предикат named\_arg, который полностью
аналогичен obj\_field. Однако, концепция named\_arg шире. Для
примера, рассмотрим как список объектов превратить в список
предикатов full\_name

\begin{bigexample}{}{}
?- obj_construct(man_v, [name, surname], ['Robert', 'Schumann'],
                 Man1), 
   obj_construct(man_v, [name, surname], ['Clara', 'Wieck'],
                 Man2),
   Obj_List = [Man1, Man2], 

   findall(full_name(Name, Surname), 
           (member(Obj, Obj_List), 
            named_args_unify(Obj, [name, surname], 
                                  [Name, Surname])
            ), 
           List2
           ).

Man1 = man_v(_G682, 'Robert', 'Schumann', _G685, _G686),
Man2 = man_v(_G725, 'Clara', 'Wieck', _G728, _G729),
Obj_List = [man_v(_G682, 'Robert', 'Schumann', _G685, _G686), 
            man_v(_G725, 'Clara', 'Wieck', _G728, _G729)],
List2 = [full_name('Robert', 'Schumann'), 
         full_name('Clara', 'Wieck')].
\end{bigexample}

Здесь, вероятно требуются пояснения.  Первые три предиката
создают список Obj\_List, содержащий два объекта типа
man\_v. Четвёртый предикат findall для каждого объекта вызывает
named\_args\_unify, который сопоставляет не одно поле, а сразу
список полей со списком значений, аналогично тому, как мы это
делали в obj\_construct. Преобразовать эти списки в новые
предикаты full\_name/2 --- это уже дело обычной Прологовской
техники).

\section{Жизнь и метаморфозы объектов в \ur}

Стоит сказать пару слов о времени жизни объекта. В других
системах (например, в Java) подразумевается, что объект
существует до тех пор, пока он кому-нибудь нужен и ещё
сколько-нибудь времени. В C++ мы сами управляем его временем
жизни. В отличие от этих систем, объект \ur{} не обладает
свойством существования до тех пор, пока мы не помещяем его в
объектную базу. Иными словами, объекты \ur - это чистые
``значения'' (на что и указывает суффикс ``\_v''), их можно
уподобить числам арифметики - когда надо они есть. Их можно
использовать в выражениях, можно, как в предыдущем примере,
записывать в список (хотя это и не лучший способ работы с
объектами, но об этом будет далее). За пределами выражения они
теряют смысл.

В связи с отстутствием понятия ``времени жизни'', а точнее,
вообще понятия ``времени'' для объекта-значения (в противовес
объекту-состоянию), мы не можем изменить значение поля объекта,
если оно уже связано.

Например

\begin{example}{}{}
?- obj_construct(man_v, [sex, name, surname], 
                        [woman, 'Clara', 'Wieck'], Woman), 
   obj_field(Woman, surname, 'Schubert').
\end{example}

даст просто false.

Если мы хотим промоделировать смену фамилии в процессе
бракосочетания, нам понадобится минимум 3 объекта: мы не можем
иметь один и тот же с двумя фамилиями в разное время (так как
времени нет, если нет объектной базы или других предположений,
например о том, что A - это до, а A2 - это после). Полный пример
содержится в файле Examples/book/zagz.pl, приведём его здесь с
пояснениями и результатами вызовов.

\begin{bigexample}{}{}
% Change object's surname by Surname_Origin
zagz(A, B, Surname_Origin, A2, B2) :-

        (Surname_Origin = man; Surname_Origin = woman), !,
        
        obj_field(A, sex, A_Sex),
        obj_field(B, sex, B_Sex),
        A_Sex \= B_Sex,

        (  named_args_unify(A, [sex, surname],
                            [Surname_Origin, Surname]
                           ),
           % A doesn't change his/her surname
           A2 = A,

           % Forget your old surname
           obj_reset_fields([surname], B, B2),

           % Here is your new Surname
           obj_field(B2, surname, Surname)
        ;
           named_args_unify(B, [sex, surname],
                            [Surname_Origin, Surname]
                           ),
           B2 = B, 
           obj_reset_fields([surname], A, A2),
           obj_field(A2, surname, Surname)
        ), !.


?- obj_construct(man_v, [sex, name, surname], 
                        [woman, 'Clara', 'Wieck'], Woman), 
   obj_construct(man_v, [sex, name, surname], 
                        [man, 'Robert', 'Schumann'], Man), 
   zagz(Woman, Man, man, New_Woman, New_Man).

Woman = man_v(woman, 'Clara', 'Wieck', _G6479, _G6480),
Man = man_v(man, 'Robert', 'Schumann', _G6525, _G6526),
New_Woman = man_v(woman, 'Clara', 'Schumann', _G6661, _G6662),
New_Man = man_v(man, 'Robert', 'Schumann', _G6525, _G6526).

?- obj_construct(man_v, [sex, name, surname], 
                        [woman, 'Clara', 'Wieck'], Woman), 
   obj_construct(man_v, [sex, name, surname], 
                        [man, 'Robert', 'Schumann'], Man), 
   zagz(Woman, Man, woman, New_Woman, New_Man).

Woman = man_v(woman, 'Clara', 'Wieck', _G6479, _G6480),
Man = man_v(man, 'Robert', 'Schumann', _G6525, _G6526),
New_Woman = man_v(woman, 'Clara', 'Wieck', _G6479, _G6480),
New_Man = man_v(man, 'Robert', 'Wieck', _G6661, _G6662).
\end{bigexample}

Здесь предикат zags принимает на вход два объекта A и B (история
происходит уже, вероятно, после знаменитой трубы) а также пол
того объекта, фамилию которого решила взять пара. На выходе
получаются (и это подчёркивается другими именами переменных) уже
новые A и B, причём фамилии у них теперь одинаковые.

Обратите внимание на следующие моменты

\begin{itemize}
\renewcommand{\labelitemi}{$\cdot$}
\item первая строка тела предиката не только проверяет
  допустимость значения параметра Surname\_Origin, но и задаёт
  его в значение man, если он не определён (соответственно,
  отсечение используется для предотвращения выдачи вариантов, но
  вы можете, конечно, смело его убрать);
\item строкой \verb|A_Sex \= B_Sex| мы запретили однополые браки;
  если вы убрали отсечение в первой строке, то, вероятно, вы
  вольны закомментировать и эту строчку;
\item далее, мы рассматриваем два варианта - B меняет фамилию, а
  A не меняет, и наоборот. Это зависит от предиката
  named\_args\_unify, удастся ли ему сопоставить пол данной
  персоны с Surname\_Origin (в данном случае он, как бы, работает
  в две стороны, Surname - читает, Surname\_Origin -
  сопоставляет. Не спрашивайте меня, что будет, если пол персоны
  не определён - с такими вещами поэкспериментируйте сами, если
  есть желание);
\item obj\_reset\_fields является куском того самого ядерного
  реактора, в котором варится уран. Он создаёт новый объект путём
  копирования всех полей старого за исключением Reset\_List -
  первого аргумента, таким образом, делает возможным изменить
  объекту поле, правда, это уже будет новый объект;
\item \verb|obj_field(A/B2, surname, Surname)| теперь связывает
  значение ``сброшенного'' поля с значением фамилии другого
  объекта. Нота бене - она может быть не задана до вызова
  процедуры. Тогда поведение аналогично примеру N.
\item финальное отсечение необходимо для того, чтобы предикат
  выглядел детерминированным. Если вы экспериментировали с
  программой в стиле unisex, его придётся убрать, он мешает
  вариантам.
\end{itemize}

\section{Удобное отображение объектов}

При определённых обстоятельствах визуальное восприятие объектов
как термов может быть трудным. По этой причие в модуле
ur\_objects существуют предикаты obj\_pretty\_print для вывода
объектов в удобном для восприятия виде:

\begin{example}{}{}
?- obj_construct(man_v, [name, surname], ['Robert', 'Schumann'], 
                 Man), 
   obj_pretty_print(Man).

man_v ( 
  name : Robert 
  surname : Schumann 
) 

Man = man_v(_G919, 'Robert', 'Schumann', _G922, _G923).
\end{example}

При этом печатаются только те поля, с которыми связаны значения.

\section{Наследование}

Давайте перейдём теперь к более интересным случаям, связанными с
наследованием.

Создадим ещё один файл, citizen\_v.pl:

\begin{example}{}{}
:- module(citizen_v, []).

new_class(citizen_v, man_v, [country, id, birthday]).
\end{example}

Таким образом, man\_v является родителем для citizen\_v (в смысле
объектного наследования). Давайте проверим

\begin{example}{}{}
?- obj_construct(citizen_v, [sex, name, country], 
                 [man, 'Shura', 'Russia'], Citizen1), 
   obj_pretty_print(Citizen1).

citizen_v ( 
  sex : man 
  name : Shura 
  country : Russia 
) 

Citizen1 = citizen_v(man, 'Shura', _G10, _G11, _G12, 'Russia',
_G14, _G15).
\end{example}

очевидно, что арность терма citizen\_v больше арности man\_v на
количество новых полей. 

Давайте теперь создадим два гражданина и поженим.

\begin{bigexample}{}{}
?- obj_construct(citizen_v, [sex, name, surname, country], 
                 [man, 'Shura', 'Buravin', 'Russia'], A), 
   obj_construct(citizen_v, [sex, name, surname, country], 
                 [woman, 'Oksana', 'Mazur', 'Ukraine'], B), 
   zagz(A, B, woman, A2, B2), 
   obj_pretty_print(A2), 
   obj_pretty_print(B2).

citizen_v ( 
  sex : man 
  name : Shura 
  surname : Mazur 
  country : Russia 
) 
citizen_v ( 
  sex : woman 
  name : Oksana 
  surname : Mazur 
  country : Ukraine 
) 
\end{bigexample}

(в дальнейшем мы будем опускать полный Пролог вывод и
довольствоваться pretty-print-ом). На лицо изменение состояния
граждан. Хотя предикат zagz, изначально, умел работать только с
людьми (man\_v).

Давайте рассмотрим ``живой'' пример. Предположим, что теперь
кто-то захотел доработать zagz и предложил следующую модификацию:
гражданство (поле country) в результате брака должно
модифицироваться; то есть, в результате брака A и B гражданство
A должно дополняться гражданством B и наоборот.

Для этого придётся использовать списки в полях country. Пока мы
не задали жёстко типы полей, определение объекта изменять не
нужно (надо только поменять соглашения его использования. На
практике, конечно, нужно предусмотреть оба варианта - гражданство
как значение и гражданство как список, но для простоты примеров
будем полагать, что поле country, если определено, то это всегда
список).

Изменим предикат zagz (см. Examples/book/zagz2.pl):

\begin{bigexample}{}{}
:- use_module(library(ur_objects)).

% if both CA and CB are undefined the result is free
merge_countries(CA, CB, _) :- var(CA), var(CB), !.

% if CA is udefined the result is CB
merge_countries(CA, CB, CB) :- var(CA), nonvar(CB), !.

% if CB is udefined the result is CA
merge_countries(CA, CB, CA) :- nonvar(CA), var(CB), !.

% if both CA and CB are lists (sets), CC is CA U CB
merge_countries(CA, CB, CC) :-

        is_list(CA), is_list(CB),
        % remove duplicates
        list_to_set(CA, SA), list_to_set(CB, SB),
        union(SA, SB, CC).


zagz(A, B, Surname_Origin, A2, B2) :-

        (Surname_Origin = man; Surname_Origin = woman), !,
        
        named_args_unify(A, [sex, country], [A_Sex, A_Countries]), 
        named_args_unify(B, [sex, country], [B_Sex, B_Countries]), 
        A_Sex \= B_Sex,

        merge_countries(A_Countries, B_Countries, Countries2),
        obj_reset_fields([country], A, A1),
        obj_field(A1, country, Countries2),
        obj_reset_fields([country], B, B1),
        obj_field(B1, country, Countries2),

        (  named_args_unify(A1, [sex, surname],
                            [Surname_Origin, Surname]
                           ),
           % A doesn't change his/her surname
           A2 = A1,

           % Forget your old surname
           obj_reset_fields([surname], B1, B2),

           % Here is your new Surname
           obj_field(B2, surname, Surname)
        ;
           named_args_unify(B1, [sex, surname],
                            [Surname_Origin, Surname]
                           ),
           B2 = B1, 
           obj_reset_fields([surname], A1, A2),
           obj_field(A2, surname, Surname)
        ), !.
\end{bigexample}


по сравнению с версией zagz.pl мы добавили 5 строчек в zagz/5 для
изменения гражданства пары и прописали правила для
объединения множеств (особым образом выписаны случаи для
объединения списка с неопределённым значением). 

Опробуем новый вариант на тех же гражданах:

\begin{bigexample}{}{}
?- obj_construct(citizen_v, [sex, name, surname, country], 
                 [man, 'Shura', 'Buravin', ['Russia']], A), 
   obj_construct(citizen_v, [sex, name, surname, country], 
                 [woman, 'Oksana', 'Mazur', ['Ukraine']], B), 
   zagz(A, B, woman, A2, B2), 
   obj_pretty_print(A2), 
   obj_pretty_print(B2).

citizen_v ( 
  sex : man 
  name : Shura 
  surname : Mazur 
  country : [Russia,Ukraine] 
) 
citizen_v ( 
  sex : woman 
  name : Oksana 
  surname : Mazur 
  country : [Russia,Ukraine] 
) 
\end{bigexample}

Работает. Однако, как и следовало ожидать, в следующем примере

\begin{example}{}{}
?- obj_construct(man_v, [sex, name, surname], 
                        [woman, 'Clara', 'Wieck'], Woman), 
   obj_construct(man_v, [sex, name, surname], 
                        [man, 'Robert', 'Schumann'], Man), 
   zagz(Woman, Man, man, New_Woman, New_Man).

false.
\end{example}

из-за отсутствия поля country в объектах man\_v попытки его
унифицировать в named\_args\_unify фейлят предикат. 

По этой причине, для некоторых языков программирования, функции,
работающие с потомками не могут работать с родителями. Однако в
\ur{} zagz2.pl можно подправить (см. zagz3.pl, здесь приводятся
только изменённый фкагмент)

\begin{example}{}{}
        named_args_weak_unify(A, [sex, country],
                                 [A_Sex, A_Countries]
                             ), 
        named_args_weak_unify(B, [sex, country],
                                 [B_Sex, B_Countries]
                             ), 
        A_Sex \= B_Sex,

        merge_countries(A_Countries, B_Countries, Countries2),
        obj_reset_fields_weak([country], A, A1),
        named_args_weak_unify(A1, [country], [Countries2]),
        obj_reset_fields_weak([country], B, B1),
        named_args_weak_unify(B1, [country], [Countries2]),
\end{example}

\section{``слабые'' функции}

В универсальном варианте предиката zagz используются
weak-варианты функций - они просто игнорируют те поля, которые
отсутствуют в объекте. Это позволяет использовать объекты в любых
сочетаниях, например:

\begin{example}{}{}
?- obj_construct(man_v, [sex, name, surname], 
                        [man, 'Robert', 'Schumann'], A), 
   obj_construct(citizen_v, [sex, name, surname, country], 
                 [woman, 'Oksana', 'Mazur', ['Ukraine']], B), 
   zagz(A, B, _, A2, B2), 
   obj_pretty_print(A2), 
   obj_pretty_print(B2).

man_v ( 
  sex : man 
  name : Robert 
  surname : Schumann 
) 
citizen_v ( 
  sex : woman 
  name : Oksana 
  surname : Schumann 
  country : [Ukraine] 
) 
\end{example}

то есть, как говорится, каждому своё. Оксане изменили фамилию, но
Роберту страну не добавили, поскольку мы не рассматривали Шумана
в гражданской плоскости.

Концепция написания универсальных предикатов может показаться
неожиданной тому, кто привык оперировать методами объекта. Но
причина в том, что в \ur{} объект - это прежде всего объект
наблюдения. А у объекта наблюдения нет методов, только
свойства. Получив какой-либо объект в виде, допустим, man\_v, мы
не можем быть уверены, что за ним не скрывается citizen\_v. И
поэтому в \ur{} существует такое понятие, как вычисление
класса и даункаст.

Но прежде, чем рассмотреть такую важную концепцию, как даункаст,
давайте исследуем мир вычислимых полей.

\section{Вычислимые поля}

Не все атрибуты объекта имеет смысл задавать, некоторые можно
вычислить на основе других атрибутов или полей. В терминах
\ur{} такие атрибуты называются вычислимыми полями. Например,
возраст гражданина можно задать, как разность между текущем годом
и годом рождения. Текущий год определим с помощью предиката
get\_time/1, возвращающего текущее время. 

\begin{example}{}{}
:- module(citizen_v, []).

'citizen_v?'(Term, age, Age) :-

        obj_field(Term, birthday, Birthday),
        (  number(Birthday)
        -> get_time(TS),
           stamp_date_time(TS, DT, local),
           date_time_value(year, DT, Current_Year),
           Age is Current_Year - Birthday
        ;
           true
        ).
        
new_class(citizen_v, man_v, [country, id, birthday]).
\end{example}

\verb|'citizen_v?'| задаёт вычислимое поле. Данный предикат
никогда не будет вызываться напрямую. Это служебный
предикат. Его имя содержит знак вопроса и поэтому, по синтаксису
Пролога, пишется в одинарных кавычках.

Для программы, использующей объектную модель \ur, вычислимые 
поля на операциях чтения не будут отличаться от обычных.

\begin{example}{}{}
?- obj_construct(citizen_v, [birthday], [1976], C), 
   obj_field(C, age, Age), 
   obj_pretty_print(C).

citizen_v ( 
  birthday : 1976 
) 

C = citizen_v(_G2330, _G2331, _G2332, _G2333, _G2334, _G2335, _G2336, 1976),
Age = 35.

?- obj_construct(citizen_v, [], [], C), 
   obj_field(C, age, Age).

C = citizen_v(_G15, _G16, _G17, _G18, _G19, _G20, _G21, _G22).
\end{example}

Однако вы не можете присвоить значение, если не доработаете
служебный предикат. Вот как можно его видоизменить, чтобы иметь
возможность читать и писать поле возраста:

\begin{example}{}{}
'citizen_v?'(Term, age, Age) :-

        get_time(TS),
        stamp_date_time(TS, DT, local),
        date_time_value(year, DT, Current_Year),
        
        obj_field(Term, birthday, Birthday),
        (  number(Birthday)
        -> Age is Current_Year - Birthday
        ;  number(Age)
        -> Birthday is Current_Year - Age
        ;  true % leave both Age and Birthday unbound
        ).
        
\end{example}

Стоит ещё добавить, что правило вычисления поля может быть
переопределено в потомке, потому отдалённо может рассматриваться
как виртуальная функция. Более того, объект object\_v, от
которого принято наследовать все остальные объекты, уже имеет два
вычислимых поля - class и functor. При этом functor - это всегда
имя объекта, как предиката, например, citizen\_v. По правилам, он
не может перекрываться в потомке. Что касается class, то, по
умолчанию, значение этого поля совпадает с functor, но
... Впрочем, этому посвящена отдельная глава.


\section{Путешествия вниз по лестнице наследования}
\label{downcast}

Вернёмся теперь к вопросу наследования. Введём новый объект -
военнообязанный.

\begin{example}{}{}
:- module(callup_v, []).

new_class(callup_v, citizen_v, [fit_for_military_service]).
\end{example}

Вероятно, есть правило, по которым гражданин считается
военнообязанным. Допустим оно звучит так: мужчина от 18 до 25
лет. Но сложность заключается в том, что citizen\_v становится
военнообязанным не в силу создания как callup\_v, а в силу
удовлетворения этим условиям. Более того, военнообязанность может
наступить автоматически при достижении призывного
возраста. Иными словами, мало кто создаётся как
военнообязанный. Это получается как-то само-собой.

Рассмотрим такое определение citizen\_v

\begin{example}{}{}
:- module(citizen_v, []).

'citizen_v?'(Term, class, callup_v) :-

        obj_field(Term, sex, man),
        obj_field(Term, age, Age),
        between(18, 25, Age), !.

'citizen_v?'(_, class, citizen_v).

'citizen_v?'(Term, age, Age) :-

        get_time(TS),
        stamp_date_time(TS, DT, local),
        date_time_value(year, DT, Current_Year),
        
        obj_field(Term, birthday, Birthday),
        (  number(Birthday)
        -> Age is Current_Year - Birthday
        ;  number(Age)
        -> Birthday is Current_Year - Age
        ;  true % leave both Age and Birthday unbound
        ).
        

new_class(citizen_v, man_v, [country, id, birthday]).
\end{example}

По сравнению с предыдущим, мы добавили правила вычисления class,
переопределив правило его вычисления из object\_v. Это даёт такой
результат:

\begin{example}{}{}
?- obj_construct(citizen_v, [birthday], [1976], C), 
   obj_field(C, class, Class).

C = citizen_v(_G15, _G16, _G17, _G18, _G19, _G20, _G21, 1976),
Class = citizen_v.

?- obj_construct(citizen_v, [birthday], [1986], C), 
   obj_field(C, class, Class).

C = citizen_v(man, _G16, _G17, _G18, _G19, _G20, _G21, 1986),
Class = callup_v.
\end{example}

Результат, как говорится, на лицо.

Однако определить значение класса - это пол дела. Принадлежность
классу у нас определяется ещё набором полей, как вычислимых так и
обычных. Мы не можем задать объекту citizen\_v значение поля
fit_for_military_service:

\begin{example}{}{}
?- obj_construct(citizen_v, [birthday], [1986], C), 
   obj_field(C, fit_for_military_service, yes).

false
\end{example}

Потому как объект сконструирован с термом citizen\_v

\begin{example}{}{}
?- obj_construct(citizen_v, [birthday], [1986], C), 
   obj_field(C, class, Class), 
   obj_field(C, functor, Functor).

C = citizen_v(man, _G23, _G24, _G25, _G26, _G27, _G28, 1986),
Class = callup_v,
Functor = citizen_v.
\end{example}

о чём говорит то самое непереопределяемое поле functor.

Очевидно, для полного превращения гражданина в военнообязанного
(не по факту, а по возможности использования дополнительных полей
в программе) надо каким-то образом привести в соответствие класс
и функтор.

\begin{example}{}{}
?- obj_construct(citizen_v, [birthday], [1986], C), 
   obj_field(C, class, Class), 
   obj_field(C, functor, Functor),

   obj_downcast(C, M),
   obj_field(M, class, Class2), 
   obj_field(M, functor, Functor2),

   obj_field(M, fit_for_military_service, yes).

C = citizen_v(man, _G44, _G45, _G46, _G47, _G48, _G49, 1986),
Class = callup_v,
Functor = citizen_v,
M = callup_v(man, _G44, _G45, _G46, _G47, _G48, _G49, 1986, yes),
Class2 = Functor2, Functor2 = callup_v.
\end{example}

Ответ Пролога \verb|Class2 = Functor2| говорит, что мы достигли
результата с помощью предиката obj\_downcast/2.

Существует также триарная форма obj\_downcast, которая выполняет
преобразование ``насильно''. Например, возвращаясь к примеру
Шуман-Мазур, нам бы достаточно было бы написать так:

\begin{example}{}{}
?- obj_construct(man_v, [sex, name, surname], 
                        [man, 'Robert', 'Schumann'], A), 
   obj_construct(citizen_v, [sex, name, surname, country], 
                 [woman, 'Oksana', 'Mazur', ['Ukraine']], B), 

   obj_downcast(A, citizen_v, AC),

   zagz(AC, B, _, A2, B2), 
   obj_pretty_print(A2), 
   obj_pretty_print(B2).

citizen_v ( 
  sex : man 
  name : Robert 
  surname : Schumann 
  country : [Ukraine] 
) 
citizen_v ( 
  sex : woman 
  name : Oksana 
  surname : Schumann 
  country : [Ukraine] 
) 
\end{example}

чтобы сделать Роберта Шумана гражданином Украины.


\chapter{Объектная база данных}
\label{ur_recorded_db}

\section{Понятие объектной базы}

В программировании и науке о программах термин ``объектная база
данных'' используется достаточно давно, так что он успел обрасти
различными значениями. По этой причине мы сразу оговоримся, что
мы понимаем под объектной базой данных в \ur. Прежде всего,
объектная база данных \ur - это прологовская база термов. Но
мы никогда не будем обращаться к ней как к базе данных термов, а
только как к базе данных уран-объектов. Это предполагает, что
операции Урана скрывают низкоуровневый доступ к прологовской базе
как базе термов - раз, дополняют концепцию базы, как хранилища,
применительно к объектов - два и дополняют саму концепцию
объектов, изложенную в предыдущей главе - три.

Но прежде чем окунуться в новые концепции (а если точнее -
расширить ту концепцию понимания объектов, которая была изложена
в предыдущей главе), давайте вкратце рассмотрим расширенную базу
термов языка Пролог.
 
\section{Расширенная база термов}

Под ``расширенной базой термов'' мы будем понимать некоторое
расширение ISO стандарта языка. 

Как известно (изложено в литературе [1]), стандартными операциями
с базой даных Пролога являются предикаты  assert(+Term),
asserta(+Term), assertz(+Term) - для добавления терма в базу,
retract(+Term) - для удаления терма и обычная унификация для
извлечения объектов. То есть, стандартная база данных Пролога -
это то же самое, что и сама программа. По этой причине она очень
не эффективна, так как после операции retract нам нужно
перекомпилировать всю программу, чтобы избавиться от её
зависимостей от удалённого терма.

По этой причине рядом реализаций предложена расширенная база
данных (в английском языке используется термин ``recorded data
base''). В частности, такая реализация присутствует SWI Prolog.

Рассмотрим подробнее.

В отличие от стандартной базы данных Пролога расширенная не видна
программе в унификации, а потому не требует перекомпиляции всех
предикатов. Точнее, конечно, унификация присутствует, но при
унификации мы всегда говорим, с каким именно ключём происходит
унификация. В простейшем случае ключ - это атом. Так как
используется ключ, то стандартная унификация не видит термы,
спрятанные за ``замком'' и более того, имея один ключ мы видим
только термы, спрятанные с помощью него.

Рассмотрим пример.

\begin{example}{}{}
?- recordz(key1, full_name('Robert', 'Schumann')).
true.

?- recordz(key1, full_name('Clara', 'Wieck')).
true.

?- recordz(key2, full_name('Oksana', 'Mazur')).
true.

?- recordz(key2, full_name('Shura', 'Buravin')).
true.

?- recorded(key1, X).
X = full_name('Robert', 'Schumann') ;
X = full_name('Clara', 'Wieck').

?- recorded(key1, full_name('Clara', Surname)).
Surname = 'Wieck'.

?- recorded(key2, full_name('Clara', Surname)).
false.

?- recorded(key2, full_name(Name, Surname)).
Name = 'Oksana',
Surname = 'Mazur' ;
Name = 'Shura',
Surname = 'Buravin'.
\end{example}

Как видим, ключи разбивают одну физическую базу на много
логических баз. Но мы всегда можем думать о них, как о различных
базах.

Для удаления записей используется предикат erase/1.

Отметим одну важную особенность, которая будет видна при
рассмотрении всех низкоуровневых предикатов доступа к базе. Термы
(объекты) прологовской базы всегда упорядочены в том порядке,
который задаётся при их вставке. Как правило мы используем
вставку в конец. Поэтому, при извлечении, порядок объектов будет
определяться порядком их вставки (при использовании прологовской
базы).

\section{База данных \ur}

Как уже говорилось, мы не будем использовать recorded database
напрямую. Более того, лучше не думать о recorded database
конкретной реализации пролога. Нам важна концепция. О способах
реализации данной концепции в \ur{} ещё будет сказано --- вообще
говоря, она не обязана вообще использовать прологовскую базу.

Итак, для работы с объектной базой \ur{} необходимо загрузить
модуль lib(ur\_recorded\_db). Вот основные предикаты модуля

\begin{description}
\item \verb|db_put_object(+DB_Key, +Object)| поместить объект в
  базу (\ref{db_put_object})
\item \verb|db_recorded(+DB_Key, ?Term)| унифицировать Term с
  базой (\ref{db_recorded})
%db_recorded(+DB_Key, ?Term, -DB_Ref)
%db_record_all(+DB_Key, :Pred)
\item \verb|bind_term_in_db(+DB_Key, ?Term)| унифицировать термы в
  базе с Term (\ref{bind_term_in_db})

%db_erase_object(+DB_Key, +Key, +Key_Value)
\item \verb|db_erase(+DB_Ref)| удалить объект по физическому
  адресу (\ref{db_erase})

\item \verb|db_iterate(+DB_Key, +Query, ?Term)| аналогично
  \verb|db_recorded(+DB_Key, ?Term)|, но использовать Query
  (\ref{db_iterate/3})
\item \verb|db_iterate(+DB_Key, +Query, ?Term, -DB_Ref, :Pred)|
  дополнительно фильтровать записи с помощью Pred/1
\item \verb|db_iterate_replace(+DB_Key, :Pred, +Query)| с помощью
  предиката \verb|Pred(+Obj_In, -Obj_Out, -Is_Succ)| провести
  замену всех объектов, удовлетворяющих Query
  (\ref{db_iterate_replace})
\item \verb|db_iterate_replace(+DB_Key, :Pred, +Query, +Lim)|
  заменить не более Lim объектов
\item
  \verb|db_iterate_replace(+DB_Key, :Pred, +Query, +Lim, :Pred2)|
  дополнительная фильтрация Query с помощью Pred2/1, аналогично
  db\_iterate/5
\item \verb|db_reset(+DB_Key, +Reset_List, +Query)| сброс полей
  Reset\_List объектов, удовлетворяющих Query в базе DB\_Key (\ref{db_reset})

\item \verb|db_object_class(+DB_Key, ?Class)| определение всех
  функторов для предикатов, хранящихся в базе
  (\ref{db_object_class})

\item \verb|db_size(+DB_Key, ?N)| определение количества записей
\item \verb|clear_db(+DB_Key)| очистить базу (\ref{clear_db})
\item \verb|filter_on_db(+DB_Key, +Field_Names, +Field_Values)|
  профильтровать базу - оставить только унифицированные объекты
  (\ref{filter_on_db})
\item \verb|db_copy(+DB_In, +DB_Out)| копирование всех записей из
  одной базы в другую (\ref{db_copy})
\item \verb|db_search(+DB_In, +DB_Out, :Pred)| копирование только
  тех записей, для которых Pred вычисляется в true
  (\ref{db_search})
%db_move_all_data
\item \verb|dump_db(+DB_Key)| отладочная печать содержимого базы
  (\ref{dump_db})
%db_merge
\end{description}


\section{Добавление и чтение объектов (db\_put\_object,
  db\_recorded)}
\label{db_put_object}
\label{db_recorded}

db\_put\_object помещает объект в базу DB\_Key, db\_recorded -
читает (унифицирует) объект

\begin{example}{База people}{people_db}
?- obj_construct(man_v, [sex, name], [man, 'Adam'], Man), 
   db_put_object(people, Man).

?- obj_construct(man_v, [sex, name], [woman, 'Eva'], Man), 
   db_put_object(people, Man).

?- db_recorded(people, X).
X = man_v(man, 'Adam', _G741, _G742, _G743) ;
X = man_v(woman, 'Eva', _G741, _G742, _G743).

?- obj_construct(citizen_v, [sex, surname, country], 
                 [man, 'Mayakovsky', ['Soviet Union']], Man), 
   db_put_object(people, Man). 

?- db_recorded(people, X).
X = man_v(man, 'Adam', _G1027, _G1028, _G1029) ;
X = man_v(woman, 'Eva', _G1027, _G1028, _G1029) ;
X = citizen_v(man, _G1026, 'Mayakovsky', _G1028, _G1029, 
              ['Soviet Union'], _G1031, _G1032).
\end{example}

как видите, в базу можно помещать разные объекты. И в самом деле
- это просто термы Пролога. Сама база ничего не знает об их
взаимосвязи, например, о наследовании.

Для того, чтобы проиллюстрировать это на примере, давайте сначала
перейдём к более компактной форме отображения с помощью
obj\_pretty\_print. 

\begin{example}{Печать всех объектов базы}{all_db_print}
?- db_recorded(people, X), obj_pretty_print(X), fail ; true.

man_v ( 
  sex : man 
  name : Adam 
) 
man_v ( 
  sex : woman 
  name : Eva 
) 
citizen_v ( 
  sex : man 
  surname : Mayakovsky 
  country : [Soviet Union] 
) 
true.
\end{example}

(Здесь использован довольно часто употребляемый pattern Пролога -
цикл с перебором всех решений. fail заставляет искать очередной
вариант решения db\_recorded после печати объекта, а после того,
как все варианты будут перебраны, управление пойдёт по второй
ветке, и предикат вернёт true.)

\section{Унификация объектов ``в лоб''}

Как, в данном случае, организовать не вычитку объектов а
унификацию, то есть сопоставление полей, например, как найти всех
мужчин в базе people? Можно, вспомнив, что под базой объектов
\ur{} всегда лежит база термов, попытаться использовать
``запрещённый приём'' (обращение к объекту как к терму), но в
скрытой, и, как будто-бы, благопристойной форме:

\begin{example}{}{}
?- obj_construct(man_v, [sex], [man], X), 
   db_recorded(people, X).

X = man_v(man, 'Adam', _G1109, _G1110, _G1111) ;
false.
\end{example}

Как видите, с man\_v унифицируется только man\_v. Аналогично
будет с citizen\_v:

\begin{example}{}{}
?- obj_construct(citizen_v, [sex], [man], X), 
   db_recorded(people, X).

X = citizen_v(man, _G9, 'Mayakovsky', _G11, _G12, ['Soviet Union'], _G14, _G15).
\end{example}

Вот тут на помощь и приходит семейство предикатов named\_arg* .

\section{Семейство унификаторов named\_arg*}
\label{named_arg_db}

named\_arg* --- это семейство унификаторов по именованным
полям. Соответственно, те, что начинаются с named\_arg\_
унифицируют одно поле, а те, что с named\_args\_ --- списком
(как в фильме, огласите весь список)

named\_arg\_unify(+DB\_Key, ?Functor, +Field\_Name, ?Value,
?Term)

эта форма унифицирует объект по одному полю и функтору. Если
функтор не определён, то проявляется полиморфизм

\begin{example}{Поиск мужчин}{find_men}
?- named_arg_unify(people, Functor, sex, man, Man).

Functor = man_v,
Man = man_v(man, 'Adam', _G24, _G25, _G26) ;

Functor = citizen_v,
Man = citizen_v(man, _G37, 'Mayakovsky', _G39, _G40, ['Soviet Union'], _G42, _G43) 
\end{example}

естественно, Value тоже можно опустить, и тогда

\begin{example}{Поиск по половому признаку}{find_sex}
?- named_arg_unify(people, Functor, sex, V, Man).

Functor = man_v, V = man, Man = man_v(man, 'Adam', _G31, _G32,
 _G33) ;

Functor = man_v, V = woman, Man = man_v(woman, 'Eva', _G31, _G32,
 _G33) ;

Functor = citizen_v, V = man, Man = citizen_v(man, _G44,
 'Mayakovsky', _G46, _G47, ['Soviet Union'], _G49, _G50)
\end{example}

мы получим всех.

Как и для объектов-значений, рассматривавшихся в разделе
(ur\_objects), существует возможность использовать несколько
полей для унификации:

\begin{example}{}{}
?- named_args_unify(people, Functor, [name, surname], 
                    [N, S], Obj),
   (nonvar(N) -> Name = N; Name = '?'), 
   (nonvar(S) -> Surname = S; Surname = '?'), 
   format("~w ~w~n", [Name, Surname]), 
   fail; true.
      
Adam ?
Eva ?
? Mayakovsky
\end{example}

мы напечатали имена и фамилии, при этом, неопределённые поля
заменили вопросами. \verb|nonvar/1| позволил отличить
неопределённые поля от определённых, однако, данный метод очень
зависит от порядка унификации. К примеру, если попытаться найти
всех Адамов, то, как и следует ожидать, неопределённые поля
унифицируются до проверки \verb|nonvar|:

\begin{example}{Поиск Адамов}{adam_mayakovsky}
?- N='Adam', 
   named_args_unify(people, Functor, [name, surname], 
                    [N, S], Obj), 
   (nonvar(N) -> Name = N; Name = '?'), 
   (nonvar(S) -> Surname = S; Surname = '?'), 
   format("~w ~w~n", [Name, Surname]), fail; true.
                                                              
Adam ?
Adam Mayakovsky
\end{example}

Т.о., можно сказать, что предикаты named\_arg* являются
не очень совершенным методом работы с базой объектов и могут
рассматриваться только как низкоуровневые предикаты. При их
использовании мы сталкиваемся со следующими проблемами:

\begin{itemize}
\item[1)] Нельзя указать, что поле несвязано. Можно только
  протестировать значение в каком-то месте выражения, что
  чувствительно к порядку предикатов и
\item[2)] Унификация простирается только на переменные и объекты в
  выражении. При связывании поля name с именем Adam значения в
  базе остались не изменными. Т.о., унификация здесь
  односторонняя.
\end{itemize}

В дальнейшем мы покажем, как решаются эти проблемы с помощью
предикатов модуля ur\_recorded\_db. Сейчас дадим ещё несколько
базовых (низкоуровневых) предикатов.

\section{Удаление объектов из базы по физическим адресам
  (db\_erase)}
\label{db_erase}
\label{db_copy}

Для удаления объекта из базы его необходимо, для начала,
найти. Пока нам известно только два способа поиска объекта -
db\_recorded и named\_arg*. Однако, можно сказать, что независимо
от способа поиска удаление всегда идёт по следующему сценарию

\begin{enumerate}
\item Мы должны найти некий идентификатор объекта в базе.
\item Мы должны передать этот идентификатор в предикат удаления
  объекта db\_erase.
\end{enumerate}

Идентификатор объекта в базе --- это либо, \tn, физический адрес,
либо ключ. Ключи - это большая концепция, она будет рассмотрена в
разделе \ref{keys}, здесь же рассмотрим удаление объектов по их
физическому адресу.

При этом, под физическим адресом будем понимать непрозрачный
идентификатор, используемый конкретной реализацией базы. При этом
модуль ur\_recorded\_db использует такую структуру физического
адреса, которая однозначно идентифицирует и саму базу и
конкретную запись в ней. То есть, при использовании различных баз
физический адрес всегда получается связан с той базой, для
которой он получен и, при удалении объекта, нет надобности
ссылаться на базу.

Например

\begin{bigexample}{Удаление объектов по физическим адресам}%
               {db_erase_example}
?- db_copy(people, people1).
true.

?- db_copy(people, people2).
true.

?- findall(Ref, 
           named_arg_unify(people1, citizen_v, name, _, _, Ref), 
           Ref_List1), 
   findall(Ref, 
           named_arg_unify(people2, man_v, name, _, _, Ref), 
           Ref_List2), 
   append(Ref_List1, Ref_List2, Ref_List), 
   !, 
   (member(Ref, Ref_List), db_erase(Ref), fail; true).

Ref_List1 = [recorded(<record>(0x2134e18))],

Ref_List2 = [recorded(<record>(0x2134d20)), 
             recorded(<record>(0x2134d58))],

Ref_List = [recorded(<record>(0x2134e18)), 
            recorded(<record>(0x2134d20)), 
            recorded(<record>(0x2134d58))].

?- db_recorded(people1, T).
T = man_v(man, 'Adam', _G304, _G305, _G306) ;
T = man_v(woman, 'Eva', _G304, _G305, _G306).

?- db_recorded(people2, T).                                        
T = citizen_v(man, _G303, 'Mayakovsky', _G305, _G306, 
              ['Soviet Union'], _G308, _G309).
\end{bigexample}

Рассмотрим пример подробно.

\begin{enumerate}
\item C помощью предиката db\_copy/2 создаём две полные копии базы
  people - people1 и people2.
\item С помощью findall и named\_arg\_unify/6 находим все объекты
  с функтором citizen\_v в базе people1 и складываем их
  физические адреса в Ref\_List1. Аналогично для базы people2
  находим объекты man\_v и формируем Ref\_List2.
\item Объединяем два списка физических адресов.
\item Удаляем найденные объекты.
\item Делая запросы к базам people1 и people2 убеждаемся в том,
  что people1 очищена от объектов citizen\_v, а people2 --- от
  man\_v.
\end{enumerate}

Следует в очередной раз подчеркнуть, что построение списка по
базе --- операция крайне неэффективная, если размер этих списков
никак не ограничен. В данном случае, мы использовали этот приём
только для того, чтобы показать связанность адреса с ``его''
базой после смешивания всех адресов в одном списке.

\section{Печать содержимого базы (dump\_db)}
\label{dump_db}

В примере \ref{db_erase_example} мы использовали откат для
распечатки содержимого базы. Модуль ur\_recorded\_db определяет
предикаты dump\_db, которые можно использовать для отладочной
распечатки.

\begin{example}{}{}
?- [logging/logging].
% logging/logging compiled into logging 0.01 sec, 2,168 bytes
true.
\end{example}

(проинициализировали систему отладочной печати)

\begin{example}{}{}
?- dump_db([], people1).

[1]: Dump the people1 DB:  :[logging]
[2]: man_v(man,Adam,_G84,_G85,_G86) man_v(woman,Eva,_G84,_G85,_G86)
  :[logging]                                                      

?- dump_db([], people2).

[3]: Dump the people2 DB:  :[logging]
[4]: citizen_v(man,_G83,Mayakovsky,_G85,_G86,[Soviet Union],_G88,_G
89)  :[logging]                                                   
\end{example}

Первый аргумент предиката dump\_db/2 задаёт список опций
(см. \ref{logging}). Например, для вывода каждой записи базы на
новой строке необходимо добавить опцию \verb|lf(1)|.

\section{Очистка базы (clear\_db)}
\label{clear_db}

Для очистки всей базы существует предикат clear\_db/1:

\begin{example}{}{}
?- clear_db(people1), clear_db(people2), 
   dump_db([], people1), dump_db([], people2).                                                         

[5]: Dump the people1 DB:  :[logging]
[6]:  :[logging]

[7]: Dump the people2 DB:  :[logging]
[8]:  :[logging]
true.
\end{example}

\section{Классовая фильтрация (class\_descendant)}
\label{class_descendant}

Давайте теперь возвратимся к примерам \ref{find_men} и
\ref{find_sex}. Как быть, если в базе не будет объекта, имеющего
поле sex или будет, но не производный от man\_v? Ответ прост ---
если поля нет, то объект по полю sex унифицирован не будет (не
будет выбран), если есть - то будет.

Давайте рассмотрим пример. Допустим, мы хотим хранить в базе
также мужские и женские шампуни:

\begin{example}{shampoo\_v определение}{shampoo_v}
:- module(shampoo_v, []).

new_class(shampoo_v, object_v, [name, firm, sex]).
\end{example}

(создали новый модуль)

\begin{example}{}{}
?- obj_construct(shampoo_v, [firm, sex], 
                 ['Schwarzkopf', man], Obj),
    db_put_object(people, Obj).
\end{example}

(добавили объект)

\begin{example}{}{}
?- named_arg_unify(people, Functor, sex, man, Obj), 
   obj_pretty_print(Obj), fail; true.

man_v ( 
  sex : man 
  name : Adam 
) 
citizen_v ( 
  sex : man 
  surname : Mayakovsky 
  country : [Soviet Union] 
) 
shampoo_v ( 
  firm : Schwarzkopf 
  sex : man 
) 
\end{example}

А как быть, если нас интересуют только потомки man\_v?

Это можно решить, используя дополнительный предикат:

\begin{example}{}{}
?- named_arg_unify(people, Functor, sex, man, Obj), 
   (Functor = man_v ; class_descendant(man_v, Functor)), 
   obj_pretty_print(Obj), fail; true.

man_v ( 
  sex : man 
  name : Adam 
) 
citizen_v ( 
  sex : man 
  surname : Mayakovsky 
  country : [Soviet Union] 
) 
\end{example}

Выражение
\verb|Functor = man_v ; class_descendant(man_v, Functor)|
означает: когда класс (функтор) равен man\_v или является
потомком man\_v. Т.о., в данном примере, named\_arg\_unify будет
возращать все записи, для которых поле sex = man, а данное
выражение - пропускать только те, которые имеют соответствующий
класс. 

Можно, однако, составить эквивалентный, но более эффективный
запрос, поменяв порядок предикатов:

\begin{example}{Все мужчины}{all_men_print}
?- (Functor = man_v ; class_descendant(man_v, Functor)), 
   named_arg_unify(people, Functor, sex, man, Obj), 
   obj_pretty_print(Obj), fail; true.

man_v ( 
  sex : man 
  name : Adam 
) 
citizen_v ( 
  sex : man 
  surname : Mayakovsky 
  country : [Soviet Union] 
) 
\end{example}

Вопрос о том, почему данный запрос является более эффективным,
оставим читателю на самостоятельную проработку.

Вообще же, для большей эффективности запросов, следует стараться
разделять базы и не хранить шампуни в базе people, чтобы не
прибегать часто к классовой фильтрации.

\section{Получение всех классов (db\_object\_class)}
\label{db_object_class}

Иногда необходимо перебрать все классы, находящиеся в базе. Для
этого предназначен предикат db\_object\_class:

\begin{example}{}{}
?- db_object_class(people, X).

X = man_v ;
X = citizen_v ;
X = shampoo_v.
\end{example}

\section{Двусторонняя унификация с базой}
\label{bind_term_in_db}

В разделе \ref{named_arg_db} было сказано, что унификация с
помощью предикатов \na{}, несмотря на то, что выполняется между
объектами базы и выражения связывает переменные только в объектах
выражения. А что, если мы хотим заставить работать унификацию ``в
сторону базы''? \Te, например, усвоить всем мужчинам с фамилией
Маяковский имя Владимир:

(в этом разделе мы будем работать с базой people, созданной в
примере \ref{people_db}).

\begin{example}{}{}
?- clear_db(people1), db_copy(people, people1).
true.

?- named_args_unify(people1, _, 
      [sex, surname], [man, 'Mayakovsky'] , Man), 
   obj_field(Man, name, 'Vladimir'), 
   bind_term_in_db(people1, Man).

?- dump_db([lf(1)], people1).

[5]: man_v(man,Adam,_G2487,_G2488,_G2489) 
man_v(woman,Eva,_G2487,_G2488,_G2489) 
citizen_v(man,Vladimir,Mayakovsky,_G2488,_G2489,[Soviet Union],_G24
91,_G2492)                                                        
 :[logging]
\end{example}

Нетрудно видеть, что унификация состаялась.

Следует отметить, что мы не можем обращаться напрямую к полям
объектов базы, \te, obj\_field и \na{} не только работают ``в
сторону выражения'', но и не имеют прямых аналогов для работы в
другую сторону. Связывание несвязанных полей для объектов базы
всегда выполняется по схеме:

\begin{enumerate}
\item Получить связанный объект в выражении.
\item Унифицировать его с объектом в базе.
\end{enumerate}

Пункт 1 подразумевает, что мы, каким-то образом, получили в
выражении объект с тем же функтором, что в базе и провели
унификацию сначала над ним. Пункт 2 необходимо пояснить. Дело в
том, что унификация bind\_term\_in\_db работает, на самом деле, в
две стороны. Это показано в следующем примере:

\begin{example}{}{}
?- clear_db(people1), db_copy(people, people1).
true.

?- named_args_unify(people1, _, 
      [sex, surname], [man, 'Mayakovsky'] , Man), 

   obj_field(Man, name, 'Vladimir'), 
   obj_reset_fields([surname], Man, Man1), 
   obj_pretty_print(Man1), 
   bind_term_in_db(people1, Man 1), 
   obj_pretty_print(Man1).

citizen_v ( 
  sex : man 
  name : Vladimir 
  country : [Soviet Union] 
) 
citizen_v ( 
  sex : man 
  name : Vladimir 
  surname : Mayakovsky 
  country : [Soviet Union] 
) 

?- dump_db([lf(1)], people1).
[7]: man_v(man,Adam,_G2487,_G2488,_G2489) 
man_v(woman,Eva,_G2487,_G2488,_G2489) 
citizen_v(man,Vladimir,Mayakovsky,_G2488,_G2489,[Soviet Union],_G2491,_G2492)                                                        
 :[logging]
\end{example}

Мы сначала нашли объект с фамилией 'Mayakovsky', затем связали
имя, но сбросили поле фамилии, затем унифицировали с базой, в
результате чего имя перешло в базу а фамилия --- в
выражение. Переменная Man1 была распечатана дважды --- до вызова
db\_bind\_term\_in\_db и после.

То, что после сброса фамилии произошла унификация с Маяковским
--- это не более чем совпадение. На самом деле это просто
оказался единственный объект без имени. Если добавить ещё одного
мужчину без имени, то он тоже получит имя ``Владимир'':

\begin{example}{}{}
?- clear_db(people1), db_copy(people, people1).
true.

?- obj_construct(citizen_v, 
      [sex, surname], [man, 'Pickwick'], New_ Man), 
   db_put_object(people1, New_Man).
\end{example}

\begin{example}{}{}
?- named_args_unify(people1, _, 
      [sex, surname], [man, 'Mayakovsky'] , Man), 
   obj_field(Man, name, 'Vladimir'), 
   obj_reset_fields([surname], Man, Man1), 
   bind_term_in_db(people1, Man1), 
   dump_db([lf(1)], people1).

[40]: man_v(man,Adam,_G4946,_G4947,_G4948) 
man_v(woman,Eva,_G4946,_G4947,_G4948) 
citizen_v(man,_G4945,Pickwick,_G4947,_G4948,_G4949,_G4950,_G4951) 
citizen_v(man,Vladimir,Mayakovsky,_G4947,_G4948,[Soviet Union],_G49
50,_G4951)                                                        

<next solution>                                  

[41]: man_v(man,Adam,_G4943,_G4944,_G4945) 
man_v(woman,Eva,_G4943,_G4944,_G4945) 
citizen_v(man,Vladimir,Mayakovsky,_G4944,_G4945,[Soviet Union],_G49
47,_G4948)                                                        
citizen_v(man,Vladimir,Pickwick,_G4944,_G4945,[Soviet Union],_G4947
,_G4948)                                                          

<next solution>                                  

[42]: man_v(man,Adam,_G4946,_G4947,_G4948) 
man_v(woman,Eva,_G4946,_G4947,_G4948) 
citizen_v(man,Vladimir,Pickwick,_G4947,_G4948,[Soviet Union],_G4950
,_G4951)                                                          
citizen_v(man,Vladimir,Mayakovsky,_G4947,_G4948,[Soviet Union],_G49
50,_G4951)                                                        

<next solution>                                  

[43]: man_v(man,Adam,_G4946,_G4947,_G4948) 
man_v(woman,Eva,_G4946,_G4947,_G4948) 
citizen_v(man,Vladimir,Mayakovsky,_G4947,_G4948,[Soviet Union],_G49
50,_G4951)                                                        
citizen_v(man,Vladimir,Pickwick,_G4947,_G4948,[Soviet Union],_G4950
,_G4951)                                                          

...
\end{example}

однако, мы получили неожиданный побочный эффект. Наш предикат
даёт бесконечное множество решений. При анализе базы видно, что
Vladimir Pickwick и Vladimir Mayakovsky постоянно меняются
местами. Если добавить печать физических адресов, то можно
видеть, что при унификации в сторону базы в базе (это относится к
расширенной базе Пролога, но не обязательно ко всем реализациям)
создаётся новый объект, при этом старый удаляется. Таким образом,
унификация всегда находит новый объект в базе и порождает
бесконечное множество решений.

Для борьбы с данным свойством, присущим, вероятно, всем
Прологовским базам термов (из-за того, что их интерфейс построен
на assert/retract) необходимо, прежде всего, абстрагироваться от
механизма хранения и 
\begin{itemize}
\item[1)] никогда не искать объекты полным перебором базы; всегда
  использовать строгие условия отбора объектов (например, в
  данном случае, только объекты с ещё несвязанным именем);
\item[2)] унификацию в сторону базы всегда проводить для уже
  найденного путём унификации в сторону выражения объекта, не
  допуская перебора вариантов в bind\_term\_in\_db;
\item[3)] по возможности использовать более высокоуровневые
  предикаты, совмещающие поиск и унификацию.
\end{itemize}

Сейчас мы продемонстрируем, как реализовать такой доступ на
низком уровне а затем перейдём к изложению высокоуровнего языка
запросов, который, как правило, и используется в \ur{} для
подобного рода операций.

\begin{example}{}{}
?- clear_db(people1), db_copy(people, people1).
true.

?- obj_construct(citizen_v, 
      [sex, surname], [man, 'Pickwick'], New_ Man), 
   db_put_object(people1, New_Man).
\end{example}

\begin{example}{}{}
?- named_args_unify(people1, _, 
      [sex, name, surname], [man, Name, ' Mayakovsky'], Man), 
   var(Name), 
   obj_field(Man, name, 'Vladimir'), 
   obj_reset_fields([surname], Man, Man1), 
   obj_pretty_print(Man1), 
   once(bind_term_in_db(people1, Man1)), 
   dump_db([lf(1)], people1).

citizen_v ( 
  sex : man 
  name : Vladimir 
  country : [Soviet Union] 
) 

[79]: man_v(man,Adam,_G2584,_G2585,_G2586) 
man_v(woman,Eva,_G2584,_G2585,_G2586) 
citizen_v(man,_G2583,Pickwick,_G2585,_G2586,_G2587,_G2588,_G2589) 
citizen_v(man,Vladimir,Mayakovsky,_G2585,_G2586,[Soviet Union],_G25
88,_G2589)                                                        
 :[logging]
\end{example}

Вроде бы работает. Предикатом var мы отсекаем объекты со
звязанным именем а предикат once допускает bind\_term\_in\_db
только с одним объектом в базе. Проблема в том, что как
показывает pretty print, Man1 может унифицироваться и на Pickwick
и на Mayakovsky (из-за того, что в нём не связана фамилия), но
once унифицирует только один, причём произвольный (в данном
случае, зависит от порядка занесения объектов в базу Пролога):

\begin{example}{}{}
?- clear_db(people1).
true.

?- obj_construct(citizen_v, [sex, surname], [man, 'Pickwick'], New_
Man), db_put_object(people1, New_Man).
New_Man = citizen_v(man, _G1437, 'Pickwick', _G1439, _G1440, _G1441
, _G1442, _G1443).                                                

?- db_copy(people, people1).
true.
\end{example}

(Pickwick оказался перед Mayakovsky)

\begin{example}{}{}
?- named_args_unify(people1, _, 
      [sex, name, surname], [man, Name, ' Mayakovsky'], Man), 
   var(Name), 
   obj_field(Man, name, 'Vladimir'), 
   obj_reset_fields([surname], Man, Man1), 
   obj_pretty_print(Man1), 
   once(bind_term_in_db(people1, Man1)), 
   dump_db([lf(1)], people1).

citizen_v ( 
  sex : man 
  name : Vladimir 
  country : [Soviet Union] 
) 

[80]: man_v(man,Adam,_G2581,_G2582,_G2583) 
man_v(woman,Eva,_G2581,_G2582,_G2583) 
citizen_v(man,_G2580,Mayakovsky,_G2582,_G2583,[Soviet Union],_G2585
,_G2586)                                                          
citizen_v(man,Vladimir,Pickwick,_G2582,_G2583,[Soviet Union],_G2585
,_G2586)                                                          
 :[logging]
\end{example}

(и получился Vladimir Pickwick)

В связи с этой неоднозначностью необходимо дополнить правила
унификации в сторону базы следующим

\begin{itemize}
\item[4)] используйте ключи; проводите унификацию в сторону базы,
  выбирая нужный объект по ключевым полям.
\end{itemize}

Использованию ключей будет посвящена глава \ref{keys}. Сейчас же
мы рассмотрим высокоуровневые предикаты. 

\section{Поисковые запросы}

До сих пор мы рассматривали доступ к объектной базе, подобный
доступу к базе данных самого Пролога. Как уже было сказано,
прологовская база не единственная, на которой может быть
построена реализацию \ur-базы. В связи с этим, доступ с помощью
прямой низкоуровневой унификации, который использовался в
предыдущих разделах, не является оптимальным. Например, при
использовании любой реляционной базы боле эффективным является
доступ с помощью SQL запросов. \ur{} использует язык запросов
высокого уровня, который может отображаться либо в унификацию,
при использовании пролог реализации, либо в SQL, при
использовании внешней базы. Не смотря на то, что все предикаты
модуля ur\_recorded\_db работают и со внешней и со внутренней
базой, для наилучшей производительности рекомендуется
использовать язык запросов совместно с правильно подобранными
ключами (будут рассмотрены в разделе \ref{keys}).

Также следует иметь в виду, что проблема зацикливания, показанная
в разделе \ref{bind_term_in_db}, как правило, не актуальна при
правильном построении выражения запроса и использовании
предикатов данного раздела.

Вот определение языка запроса в нотации Бэкуса-Науэра:

\begin{genexample}{}{}
expr ::= expr \/ expr
expr ::= expr /\ expr
expr ::= ( expr )
expr ::= field(Value) | field(+bound) | field(+free) | true
expr ::= field(\+ Value)
\end{genexample}
 
Операция \verb|\/| означает слияние двух подвыражений по ИЛИ,
\verb|/\| - по И. Вместо \verb|field| необходимо подставить имя
поля объекта, вместо Value - переменную либо
значение. \verb|+bound|, \verb|+free| и \verb|true| - это
лексемы.

Вот примеры правильных выражений:

\begin{verbatim}
name(+free)   
% объект имеет несвязанное поле name

sex(+bound)   
% объект имеет связанное поле sex

name('Vladimir') /\ sex(man) 
% объект - мужчина по имени Vladimir

name('Vladimir') /\ name(+bound) 
% избыточное выражение, field(Value) подразумевает связанность

country(\+ 'Soviet Union') 
% объект имеет поле country со значением, не равным Soviet Union

country(\+ 'Soviet Union') /\ country(+bound) 
% избыточное выражение, \+ Value как и Value 
% подразумевает конкретное  (связанное) значение

(country('Soviet Union') \/ country(+free)) /\ name('Vladimir') 
% человек, потенциально, из SU

true
% выбор всех объектов
\end{verbatim}

Во всех приведённых примерах в качестве Value использовались
конкретные значения. Разумеется, можно использовать переменные
Пролога. Но. Все переменные в поисковом выражении должны быть
связаны до вызова предиката. Иначе выражение {\bfвсегда} даёт
пустое множество найденных элементов.

Перейдём к рассмотрению конкретных предикатов.

\subsection{db\_iterate/3}
\label{db_iterate/3}

db\_iterate является аналогом db\_recorded + унификация

В простейшем случае он перебирает все элементы (сравните с
\ref{all_db_print}) 

\begin{example}{}{}
?- db_iterate(people, true, Man), obj_pretty_print(Man), fail; true
.                                                                 
man_v ( 
  sex : man 
  name : Adam 
) 
man_v ( 
  sex : woman 
  name : Eva 
) 
citizen_v ( 
  sex : man 
  surname : Mayakovsky 
  country : [Soviet Union] 
) 
\end{example}

Аналогично можно привести аналоги ранее приведённых примеров. Вот
аналог \ref{find_men}

\begin{example}{}{}
?- db_iterate(people, sex(man), Man).

Man = man_v(man, 'Adam', _G1440, _G1441, _G1442) ;

Man = citizen_v(man, _G1445, 'Mayakovsky', _G1447, _G1448, ['Soviet
 Union'], _G1450, _G1451) ;                                       
\end{example}

В отличии от унификации, мы не можем использовать значения для
унификации с несвязанными элементами. Например

\begin{example}{}{}
?- db_iterate(people, name('Adam') /\ surname('Mayakovsky'), Man). 
false.
\end{example}

однако, в то же время, можем свободно оперировать связностью:

\begin{example}{}{}
?- db_iterate(people, (name(+bound) /\ surname(+free)) \/ (name(+fr
ee) /\ surname(+bound)), Man).                                     
Man = man_v(man, 'Adam', _G1619, _G1620, _G1621) ;
Man = man_v(woman, 'Eva', _G1619, _G1620, _G1621) ;
Man = citizen_v(man, _G1624, 'Mayakovsky', _G1626, _G1627, ['Soviet
 Union'], _G1629, _G1630) ;                                       
false.
\end{example}

(возвращает все объекты, для которых либо имя не определено, либо
фаилия. Обратите внимание на использование скобок в поисковом
выражении. Сравните с \ref{adam_mayakovsky}).

\subsection{db\_iterate/4}

Аналогично предикатам низкого уровня, мы можем получить
физические адреса, например, для удаления объектов. Вот пример
получения ``мужской'' и ``женской'' базы:

\begin{example}{}{}
?- db_copy(people, men), db_copy(people, women).

?- db_iterate(men, sex(\+ man), _, Ref), % select no man
   db_erase(Ref), fail; true.

?- db_iterate(women, sex(\+ woman), _, Ref), % select no woman
   db_erase(Ref), fail; true.

?- dump_db([lf(1)], men), dump_db([lf(1)], women).

[84]: man_v(man,Adam,_G1844,_G1845,_G1846) 
citizen_v(man,_G1843,Mayakovsky,_G1845,_G1846,[Soviet Union],_G1848
,_G1849)                                                          
 :[logging]
[85]: man_v(woman,Eva,_G1904,_G1905,_G1906) 
 :[logging]
\end{example}

Получилось.

Возвращаясь к вопросу, поставленному в разделе
\ref{class_descendant}. Добавим мужской шампунь (\ref{shampoo_v}):

\begin{example}{}{}
?- obj_construct(shampoo_v, [firm, sex], 
                 ['Schwarzkopf', man], Obj),
    db_put_object(people, Obj).
\end{example}

Как ни странно, но запрос с использованием вычислимых полей
работать не будет:

\begin{example}{}{}
?- db_iterate(people, sex(\+ man) \/ (class(\+ man_v) \/ class(\+ ci tizen_v)), _, Ref), 
   db_erase(Ref), fail; true.                    

?- dump_db([lf(1)], people).
[90]: man_v(man,Adam,_G1844,_G1845,_G1846) 
citizen_v(man,_G1843,Mayakovsky,_G1845,_G1846,[Soviet Union],_G1848
,_G1849)                                                          
shampoo_v(_G1842,Schwarzkopf,man) 
 :[logging]
\end{example}

Видно, что шампунь присутствует.

Данное свойство поисковых выражением объясняется требованием их
эффективной реализации. Вычислимые поля на Прологе нельзя
подставить в SQL запрос при использовании внешней базы. В данном
случае, на помощь приходит третья форма предиката -
db\_iterate/5.

\subsection{db\_iterate/5}

Необходимость различать предикаты Пролога по арности приводит к
тому, что каждая новая форма предиката получает дополнительный
аргумент. Так предикат, позволяющий использовать дополнительную
фильтрацию

\begin{verbatim}
db_iterate(+DB_Key, +Query, ?Term, -DB_Ref, :Pred)
\end{verbatim}

наследует все поля предыдущей формы (а потому всегда возвращает
физический адрес объекта). Дополнительно он получает параметр
Pred, который должен иметь арность 1. Для каждого объекта,
удовлетворяющего Query будет вызван Pred. Если Pred вернёт false,
объект будет пропущен. Передача true в качестве Pred аналогична
вызову db\_iterate/4.

Вот аналог примера \ref{all_men_print}, фильтрующего шампуни из
базы people. Для начала созданим вспомогательный предикат
check_man/1:

\begin{example}{}{}
check_man(Object) :- obj_field(Object, class, Class), 
   ( Class = man_v 
   ; class_descendant(man_v, Class)
   ), !.
\end{example}

(он аналогичен тому, который использовался в примере
\ref{all_men_print}, только использует class вместо functor,
см. \ref{downcast}). После этого желаемый результат достигается
применением db_iterate/5:

\begin{example}{}{}
?- db_iterate(people, sex(man), Man, _, check_man), 
   obj_pretty_print(Man), fail; true.

man_v ( 
  sex : man 
  name : Adam 
) 
% Examples/callup_v.pl compiled into callup_v 0.00 sec, 1,480 bytes
citizen_v ( 
  sex : man 
  surname : Mayakovsky 
  country : [Soviet Union] 
) 
\end{example}

Обратите внимение на автоматическую подгрузку объекта
callup_v. Это потому, что, как мы помним (\ref{downcast})
\verb|obj_field(Man, class, callup_v)| для Mayakovsky, и
вычисление class_descendant/2 потребовало загрузить определение
этого объекта.

\section{Использование ключей}
\label{keys}

+ несовершенства примера низкоуровневая унификация в базу

В примере \ref{db_erase_example} было показано использование
предиката db\_copy/2 для создания двух вспомогательных
баз. Вообще говоря, \ur{} не имеет отдельного предиката для
создания базы, равно как и для её удаления. Потому, всякое
упоминание новой базы с помещением в неё объектов может эту базу
создавать. 

Давайте исследуем, что произойдёт, если предикат db\_copy/2
использовать несколько раз.

\begin{example}{}{}
?- clear_db(people1), db_copy(people, people1), db_copy(people,
  people1), dump_db([lf(1)], people1).

[9]: man_v(man,Adam,_G742,_G743,_G744) 
man_v(woman,Eva,_G742,_G743,_G744) 
citizen_v(man,_G741,Mayakovsky,_G743,_G744,[Soviet Union],_G746,_G7
47)                                                               
man_v(man,Adam,_G742,_G743,_G744) 
man_v(woman,Eva,_G742,_G743,_G744) 
citizen_v(man,_G741,Mayakovsky,_G743,_G744,[Soviet Union],_G746,_G7
47)                                                               
 :[logging]
\end{example}

Можно видеть, что записи для каждого объекта дублируются.

Данное свойство может нарушать логическую целостность в том
случае, когда нам надо моделировать {\it существование}
объектов. В этом случае существование одного человека с именем
Adam должно обозначаться единственным объектом в базе, а у нас
получилось два Adam-а --- непонятно, это два человека или один,
представленный несколькими записями.

Мы можем принять соглашение, что объекты различаются физическими
адресами. Однако этот метод крайне несовершенен. Сейчас мы
продемонстрируем почему.

\subsection{Несостоятельность различения объектов по физическим
  адресам}

С первого взгляда может показаться, что физический адрес в базе -
это аналог указателя в C++ или Java. В соответствии с моделями
этих языков два разных указателя - это два объекта.




Определение базового класса базы.

Слияние объектов (пример).


Использование ключей в объектах

Использование типизированных полей

obj\_diff и obj\_merge

могут ли вычислимые поля перекрывать обычные. Country\_List

Упражнения





\end{document}

