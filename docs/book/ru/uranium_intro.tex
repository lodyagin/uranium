\documentclass[a4paper]{book}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\selectlanguage{russian}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{underscore} % no need to escape underscore with this pack
\usepackage[dvips]{graphicx}
\usepackage{babel}
\usepackage{verbatim}   % multi-line comments
%\usepackage{sectsty}
%\usepackage[normalem]{ulem}
%\usepackage{indentfirst}
%\usepackage{amsfonts}
%\usepackage{fancyhdr}
%\pagestyle{fancy}

\renewcommand{\labelenumii}{\asbuk{enumii})}

\def\tn{т.\thinspace н.}
\def\td{т.\thinspace д.}
\def\tp{т.\thinspace п.}
\def\to{т.\thinspace о.}
\def\To{Т.\thinspace о.}
\def\te{т.\thinspace е.}
\def\Te{Т.\thinspace е.}
\def\itd{и т.\thinspace д.}
\def\ur{Uranium}
\def\na{named\_args\_unify}

\graphicspath{{pics/}}

\lstnewenvironment{example}[2]%
   {%
    \minipage[t]{0.9\linewidth}%
    \lstset{language=Prolog, frame=single, breaklines=true,%
            breakatwhitespace=true,%
            basicstyle=\small,%
            frameround=fttt,frame=trBL,%
            caption={#1},label={#2}}%
   }%
   {\endminipage\smallskip}

\lstnewenvironment{bigexample}[2]%
   {%
    \lstset{language=Prolog, frame=single, breaklines=true,%
            breakatwhitespace=true,%
            basicstyle=\small,%
            xrightmargin=0.05\linewidth,%
            xleftmargin=0.05\linewidth,%
            frameround=fttt,frame=trBL,%
            caption={#1},label={#2}}%
   }%
   {\smallskip}

\lstnewenvironment{genexample}[2]%
   {%
    \minipage[t]{0.9\linewidth}%
    \lstset{frame=single, breaklines=true,%
            breakatwhitespace=true,%
            basicstyle=\small,%
            frameround=fttt,frame=trBL,%
            caption={#1},label={#2}}%
   }%
   {\endminipage\smallskip}

\begin{document}
\title{{\bf\ur}\\ \medskip  Пролог-библиотека для автоматизации
  тестирования ПО}
\author{Сергей Лодягин\\ \texttt{lodyagin@gmail.com}}
\date{\today}
\maketitle

\tableofcontents

\part{\ur-руководство}
\chapter{Обзор библиотеки \ur}

Пролог-библиотека \ur (\url{http://uranium-test.sourceforge.net})
является свободной библиотекой с открытым исходным кодом, которая
защищена лицензией LGPL - она даёт права модифицировать или
каким-либо другим образом использовать исходный код, с тем
ограничением, что всеми доработками самой библиотеки необходимо
делиться с разработчиками, но использоваться может она в любых
проектах - как открытых, так и закрытых.

\begin{comment}
После скачивания исходного кода создаётся каталог uranium-test, в
котором основное пространство занимает подкаталог U-238/u. Сейчас
мы рассмотрим структуру этого каталога:

\begin{verbatim}
action
algorithm
gt
html
http
internal
internet
nfa
parser
rand
regex
tc_support
util
v
ixpath.pl
ur_atoms.pl
ur_fixed.pl
ur_io.pl
ur_lists.pl
ur_math.pl
ur_messages.pl
...
\end{verbatim}

Это и есть библиотека \ur.

\section{Каталог lib}

Это фундамент. Содержит базовые пакеты.

\begin{description} 
\item ur_objects.pl данный пакет реализует концепцию
  объектов, которой будет посвящена глава \ref{ur_objects}.
\item ur_recorded_db.pl объектная база данных, которая
  будет рассмотрена в главе \ref{ur_recorded_db}.
\end{description}

\section{Каталог logging}

Гибкое логирование --- важная составная часть системы автотестов.

\begin{description}
\item logging.pl содержит базовые предикаты, см. главу
  \ref{logging}.
\end{description}
\end{comment}

\chapter{Пролог и объекты}
\label{ur_objects}

\section{Концепция объектов в \ur}
Считается, что объектно-ориентированное программирование является
альтернативой логическому/функциональному (или наоборот). Авторы
\ur{} придерживаются другого взгляда - эти две методологии
дополняют друг друга. Точнее, объектно-ориентированное
программирование может быть реализовано на базе логического и
являться его расширением. Подобное расширение, чисто
теоретически, может давать спорные преимущества, однако, мы
убедились на практике, что подобным образом удобно описывать
аспекты тестируемых систем, в составе которых мы выделяем
``объекты''. 

При этом, с точки зрения Пролога, объект - это просто терм
заданной арности. Мы используем особый суффикс для того, чтобы
отличать термы - объекты от обычных термов. Например, когда мы
пишем patient_v то имеем в виду объект. 

Отличие объектов от прологовских термов состоит в том, что один
объект может быть пронаследован от другого объекта. При этом
арность объекта-наследника будет больше или равна арности
объекта-родителя. Это затрудняет обращение к полям терма обычным,
прологовским методом, потому что смысл объектно-ориентированного
подхода заключается в том, чтобы оперировать как с родителем, так
и с любым его потомком посредством одних и тех же операций.

Рассмотрим следующий пример.

Создадим файл man_v.pl со следующим содержимым\footnote{Объект man_v и его
  производные, на которых построены примеры данной книги, используются, в том
  числе, в некоторых unit-тестах, а потому они содержаться в папке U-238/u/v/test.}:

\begin{example}{man_v object definition}{man_v}
:- module(man_v, []).

new_class(man_v, object_v, 
          [sex, name, surname, weight, height]).
\end{example}

Следует обратить внимание на несколько правил:

\begin{enumerate}
\item Имя объекта, как уже было сказано, всегда должно
  заканчиваться на ``_v''.
\item В каждом файле лучше можно объявлять несколько объектов, однако это
  рекомендуется делать только если они составляют собой ``семью'', имеющую
  общего предка.
\item Имя файла должно совпадать с именем объекта или объекта-предка, если в
  файле определено более одного объекта (плюс расширение ``.pl'').
\item В файле должен быть объявлен модуль, имя которого совпадает
  с именем объекта.
\item Список экспортируемых из модуля предикатов, как правило,
  оставляют пустым, потому что для подгрузки объектов
  используется динамический механизм.
\item Сам объект объявляется с помощью предикатов-фактов
  new_class/3 или new_class/4. Первая позиция даёт имя новому
  объекту, вторая - указывает имя объекта-предка, третья содержит
  список полей и, опционально, их тип (см. далее), четвёртая
  (необязательная) - задаёт список полей, формирующих ключ
  (см. \ref{keys}).
\end{enumerate}

(Полное описание формата файла-определения объекта, равно как и
дополненный набор правил будет дан в разделе
\ref{object_file_format}).

В определении объекта мы указали в качестве предка object_v. Этот
объект определён в \ur{} и, обычно, используется в качестве
самого базового класса для любого \ur{} объекта (обратите внимание,
мы не можем создать объект, не указав предка).

Для того, чтобы динамическая система подгрузки \ur{} могла обнаружить наш
объект, его надо разместить в один из рабочих подкаталогов (todo: расписать,
какие подкатаоги рассматриваются как рабочие) на глубине вложенности не более 5
(точную максимальную глубину можно изменить в коде, благо он открыт).

Для работы с объектами необходимо загрузить модуль v:

\begin{example}{}{}
[u(v)].
\end{example}

После успешной загрузки можно создать нового человека, используя
существующий для этой цели предикат obj_construct:

% добавить про сортировку полей по названием и отличие структур
% объектов от других языков

\begin{example}{}{}
?- obj_construct(man_v, [name], ['Tom'], Man1).
Man1 = man_v(10, _G395, 'Tom', _G397, _G398, _G399).
\end{example}

Первым параметром предиката obj_construct/4 идёт имя объекта. Вторым - список
полей, которые мы хотим задать при его создании (попробуйте задать пустой
список в качестве упражнения). Третьим - значения полей. При этом количество
элементов в первом списке должно совпадать с количеством элементов во втором, в
противном случае вы получите исключение domain error. Последним параметром
идёт всегда имя переменной, в которую и будет помещён созданный объект.

В результате Пролог присвоил значение переменной Man1 и
проинициализировал заданные при конструировании поля. Остальные
поля оказались не связанные. Коль скоро для Пролога объект ничем
не отличается от терма, то можно было бы использовать обычный
позиционный синтаксис для задания, например, веса и роста новому
объекту

\begin{example}{}{}
?- class_fields(man_v, Flds).
Flds = [height, name, sex, surname, weight].

?- obj_construct(man_v, [name], ['Tom'], Man1), 
   man_v(_, 54, _, _, _, 3.9) = Man1.

Man1 = man_v(10, 54, 'Tom', G3767, _G3769, 3.9).
\end{example}

%u_class
%u_object

\section{Доступ к полям объекта}

Обратите внимание, что для позиционного доступа мы вынуждены были запросить
порядок полей, так как в терме они оказываются отсортированными по алфавиту
(кроме того, первое поле всегда хранит числовой идентификатор класса объекта).

Более того, этот метод, как уже говорилось, не проходит для объектов
по следующим причинам

\begin{enumerate}
\item В процессе моделирования мы можем добавлять поля к объекту и
позиции будут смещены и арность поменяется.
\item Мы не можем использовать данный метод с потомками, у них будет
другой функтор и арность.
\end{enumerate}

Поэтому для доступа к полям объекта {\it всегда\/} используются
имена полей. Иными словами, верхний пример нужно переписать таким
образом:

\begin{example}{}{}
?- obj_construct(man_v, [name], ['Tom'], Man1), 
   obj_field(Man1, weight, 3.9), 
   obj_field(Man1, height, 54).

Man1 = man_v(10, 54, _'Tom', G3767, _G3769, 3.9).
\end{example}

Следует подчеркнуть, что предикат obj_field не устанавливает
значение поля, а связывает его в терминах пролога, например

\begin{example}{}{}
?- obj_construct(man_v, [name], ['Mars'], Man1), 
   obj_field(Man1, name, Name).

Man1 = man_v(_G3739, 'Mars', _G3741, _G3742, _G3743),
Name = 'Mars'.
\end{example}
(чтение поля имени)

\begin{example}{}{}
?- obj_construct(man_v, [name], ['Mars'], Man1), 
   obj_field(Man1, name, Name), 
   obj_field(Man1, surname, Name).

Man1 = man_v(10, _G3776, 'Mars', G3779, _'Mars', _G3780),
Name = 'Mars'.
\end{example}
(превращение имени в фамилию)

и даже

\begin{example}{}{}
?- obj_construct(man_v, [name], ['Robert'], Man1), 
   obj_construct(man_v, [name], ['Clara'], Man2), 
   obj_field(Man1, surname, Surname), 
   obj_field(Man2, surname, Surname), 
   obj_field(Man1, surname, 'Schumann').

Man1 = man_v(10, _G927, 'Robert', _G929, 'Schumann', _G931),
Man2 = man_v(10, _G985, 'Clara', _G987, 'Schumann', _G989).
\end{example}

(после второго obj_field фамилии двух людей (здесь Man
использовалось в широком значении ``человек'') стали связанными,
и выбор фамилии для Man1 тут же задал фамилию Man2 (очевидно,
здесь мы смоделировали, в первом приближении, случай женитьбы
Роберта Шумана и Клары Вик. К этому примеру мы будем ещё
неоднократно возвращаться).

Существует более короткий и универсальный синтаксис доступа к полям
объекта. Предыдущий пример можно было бы переписать в следующем виде:

\begin{example}{}{}
?- obj_construct(man_v, [name], ['Robert'], Man1), 
   obj_construct(man_v, [name], ['Clara'], Man2), 
   Man1/surname ^= Man2/surname,
   'Schumann' ^= Man1/surname.

Man1 = man_v(10, _G927, 'Robert', _G929, 'Schumann', _G931),
Man2 = man_v(10, _G985, 'Clara', _G987, 'Schumann', _G989).
\end{example}

В дальнейшем мы будем использовать оба синтаксиса.

В качестве другого примера, рассмотрим как список объектов превратить в список
предикатов full_name

\begin{bigexample}{}{}
?- obj_construct(man_v, [name, surname], ['Robert', 'Schumann'],
                 Man1), 
   obj_construct(man_v, [name, surname], ['Clara', 'Wieck'],
                 Man2),
   Obj_List = [Man1, Man2], 

   findall(full_name(Name, Surname), 
           (member(Obj, Obj_List), 
            Obj / [name, surname] ^= [Name, Surname]
            ), 
           List2
           ).

Man1 = man_v(10, _G1354, 'Robert', _G1356, 'Schumann', _G1358),
Man2 = man_v(10, _G1412, 'Clara', _G1414, 'Wieck', _G1416),
Obj_List = [man_v(10, _G1354, 'Robert', _G1356, 'Schumann', _G1358), man_v(10, _G1412, 'C
lara', _G1414, 'Wieck', _G1416)],                                                       
List2 = [full_name('Robert', 'Schumann'), full_name('Clara', 'Wieck')].
\end{bigexample}

Здесь, вероятно требуются пояснения.  Первые три предиката
создают список Obj_List, содержащий два объекта типа
man_v. Четвёртый предикат findall для каждого объекта применяет
селектор-список, который сопоставляет не одно поле, а сразу
списко полей со списком значений, аналогично тому, как мы это
делали в obj_construct. Преобразовать эти списки в новые
предикаты full_name/2 --- это уже дело обычной Прологовской
техники).

Следует заметить, что без использования универсального синтаксиса (предиката
\verb|^=/2|) ту же операцию можно выполнить с использованием named_args_unify/3:

\begin{example}{}{}
named_args_unify(Obj, [name, surname], [Name, Surname])
\end{example}


\section{Жизнь и метаморфозы объектов в \ur}
\label{object_life}

Стоит сказать пару слов о времени жизни объекта. В других
системах (например, в Java) подразумевается, что объект
существует до тех пор, пока он кому-нибудь нужен и ещё
сколько-нибудь времени. В C++ мы сами управляем его временем
жизни. В отличие от этих систем, объект \ur{} не обладает
свойством существования до тех пор, пока мы не помещяем его в
объектную базу. Иными словами, объекты \ur - это чистые
``значения'' (на что и указывает суффикс ``_v''), их можно
уподобить числам арифметики - когда надо они есть. Их можно
использовать в выражениях, можно, как в предыдущем примере,
записывать в список (хотя это и не лучший способ работы с
объектами, но об этом будет далее). За пределами выражения они
теряют смысл.

В связи с отстутствием понятия ``времени жизни'', а точнее,
вообще понятия ``времени'' для объекта-значения (в противовес
объекту-состоянию), мы не можем изменить значение поля объекта,
если оно уже связано.

Например

\begin{example}{}{}
?- obj_construct(man_v, [sex, name, surname], 
                        [woman, 'Clara', 'Wieck'], Woman), 
   obj_field(Woman, surname, 'Schumann').
\end{example}

даст просто false.

В данном случае следует применить obj_rewrite, который создаёт новый объект:

\begin{example}{}{}
?- obj_construct(man_v, [sex, name, surname], 
                        [woman, 'Clara', 'Wieck'], Girl), 
   obj_rewrite(Girl, [surname], _, ['Schumann'], Woman).
\end{example}

Третий агрумент obj_rewrute/5 связывает старое значение поля, что может быть
использовано, в частности, для построения следующих конструкций:

\begin{example}{}{}
?- obj_construct(man_v, [sex, name, surname, weight], 
                        [woman, 'Clara', 'Schumann', 65], Woman), 
   obj_rewrite(Woman, [weight], [Old_Weight], [New_Weight], Woman2),
   New_Weight is Old_Weight + 3.
\end{example}


\section{Удобное отображение объектов}

При определённых обстоятельствах визуальное восприятие объектов
как термов может быть трудным. По этой причие в модуле
ur_objects существуют предикаты obj_pretty_print для вывода
объектов в удобном для восприятия виде:

\begin{example}{}{}
?- obj_construct(man_v, [name, surname], ['Robert', 'Schumann'], 
                 Man), 
   obj_pretty_print(Man).

man_v ( 
  name : Robert 
  surname : Schumann 
) 
Man = man_v(10, _G1668, 'Robert', _G1670, 'Schumann', _G1672).
\end{example}

При этом печатаются только те поля, с которыми связаны значения.

\section{Наследование}

Давайте перейдём теперь к более интересным случаям, связанными с
наследованием.

Создадим ещё один файл, citizen_v.pl:

\begin{example}{Определение citizen_v}{citizen_v_sample}
:- module(citizen_v, []).

new_class(citizen_v, man_v, [country, id, birthday]).
\end{example}

Таким образом, man_v является родителем для citizen_v (в смысле
объектного наследования). Давайте проверим

\begin{example}{}{}
?- obj_construct(citizen_v, [sex, name, country], 
                 [man, 'Shura', 'Russia'], Citizen1), 
   obj_pretty_print(Citizen1).

citizen_v ( 
  country : Russia 
  name : Shura 
  sex : man 
) 
Citizen1 = citizen_v(11, _G1680, 'Russia', _G1682, _G1683, 'Shura', man, _G1686, _G1687).
\end{example}

очевидно, что арность терма citizen_v больше арности man_v на
количество новых полей. 

\begin{comment}
% Переделать под spider
Давайте теперь создадим два гражданина и поженим.

\begin{bigexample}{}{}
?- obj_construct(citizen_v, [sex, name, surname, country], 
                 [man, 'Shura', 'Buravin', 'Russia'], A), 
   obj_construct(citizen_v, [sex, name, surname, country], 
                 [woman, 'Oksana', 'Mazur', 'Ukraine'], B), 
   zagz(A, B, woman, A2, B2), 
   obj_pretty_print(A2), 
   obj_pretty_print(B2).

citizen_v ( 
  sex : man 
  name : Shura 
  surname : Mazur 
  country : Russia 
) 
citizen_v ( 
  sex : woman 
  name : Oksana 
  surname : Mazur 
  country : Ukraine 
) 
\end{bigexample}

(в дальнейшем мы будем опускать полный Пролог вывод и
довольствоваться pretty-print-ом). На лицо изменение состояния
граждан. Хотя предикат zagz, изначально, умел работать только с
людьми (man_v).

Давайте рассмотрим ``живой'' пример. Предположим, что теперь
кто-то захотел доработать zagz и предложил следующую модификацию:
гражданство (поле country) в результате брака должно
модифицироваться; то есть, в результате брака A и B гражданство
A должно дополняться гражданством B и наоборот.

Для этого придётся использовать списки в полях country. Пока мы
не задали жёстко типы полей, определение объекта изменять не
нужно (надо только поменять соглашения его использования. На
практике, конечно, нужно предусмотреть оба варианта - гражданство
как значение и гражданство как список, но для простоты примеров
будем полагать, что поле country, если определено, то это всегда
список).

Изменим предикат zagz (см. Examples/book/zagz2.pl):

\begin{bigexample}{}{}
:- use_module(library(ur_objects)).

% if both CA and CB are undefined the result is free
merge_countries(CA, CB, _) :- var(CA), var(CB), !.

% if CA is udefined the result is CB
merge_countries(CA, CB, CB) :- var(CA), nonvar(CB), !.

% if CB is udefined the result is CA
merge_countries(CA, CB, CA) :- nonvar(CA), var(CB), !.

% if both CA and CB are lists (sets), CC is CA U CB
merge_countries(CA, CB, CC) :-

        is_list(CA), is_list(CB),
        % remove duplicates
        list_to_set(CA, SA), list_to_set(CB, SB),
        union(SA, SB, CC).


zagz(A, B, Surname_Origin, A2, B2) :-

        (Surname_Origin = man; Surname_Origin = woman), !,
        
        named_args_unify(A, [sex, country], [A_Sex, A_Countries]), 
        named_args_unify(B, [sex, country], [B_Sex, B_Countries]), 
        A_Sex \= B_Sex,

        merge_countries(A_Countries, B_Countries, Countries2),
        obj_reset_fields([country], A, A1),
        obj_field(A1, country, Countries2),
        obj_reset_fields([country], B, B1),
        obj_field(B1, country, Countries2),

        (  named_args_unify(A1, [sex, surname],
                            [Surname_Origin, Surname]
                           ),
           % A doesn't change his/her surname
           A2 = A1,

           % Forget your old surname
           obj_reset_fields([surname], B1, B2),

           % Here is your new Surname
           obj_field(B2, surname, Surname)
        ;
           named_args_unify(B1, [sex, surname],
                            [Surname_Origin, Surname]
                           ),
           B2 = B1, 
           obj_reset_fields([surname], A1, A2),
           obj_field(A2, surname, Surname)
        ), !.
\end{bigexample}


по сравнению с версией zagz.pl мы добавили 5 строчек в zagz/5 для
изменения гражданства пары и прописали правила для
объединения множеств (особым образом выписаны случаи для
объединения списка с неопределённым значением). 

Опробуем новый вариант на тех же гражданах:

\begin{bigexample}{}{}
?- obj_construct(citizen_v, [sex, name, surname, country], 
                 [man, 'Shura', 'Buravin', ['Russia']], A), 
   obj_construct(citizen_v, [sex, name, surname, country], 
                 [woman, 'Oksana', 'Mazur', ['Ukraine']], B), 
   zagz(A, B, woman, A2, B2), 
   obj_pretty_print(A2), 
   obj_pretty_print(B2).

citizen_v ( 
  sex : man 
  name : Shura 
  surname : Mazur 
  country : [Russia,Ukraine] 
) 
citizen_v ( 
  sex : woman 
  name : Oksana 
  surname : Mazur 
  country : [Russia,Ukraine] 
) 
\end{bigexample}

Работает. 

\section{``слабые'' функции}

Как и следовало ожидать, в следующем примере

\begin{example}{}{}
?- obj_construct(man_v, [sex, name, surname], 
                        [woman, 'Clara', 'Wieck'], Woman), 
   obj_construct(man_v, [sex, name, surname], 
                        [man, 'Robert', 'Schumann'], Man), 
   zagz(Woman, Man, man, New_Woman, New_Man).

false.
\end{example}

из-за отсутствия поля country в объектах man_v попытки его
унифицировать в named_args_unify фейлят предикат. 

По этой причине, для некоторых языков программирования, функции,
работающие с потомками не могут работать с родителями. Однако в
\ur{} zagz2.pl можно подправить (см. zagz3.pl, здесь приводятся
только изменённый фкагмент)

\begin{example}{}{}
        named_args_weak_unify(A, [sex, country],
                                 [A_Sex, A_Countries]
                             ), 
        named_args_weak_unify(B, [sex, country],
                                 [B_Sex, B_Countries]
                             ), 
        A_Sex \= B_Sex,

        merge_countries(A_Countries, B_Countries, Countries2),
        obj_reset_fields_weak([country], A, A1),
        named_args_weak_unify(A1, [country], [Countries2]),
        obj_reset_fields_weak([country], B, B1),
        named_args_weak_unify(B1, [country], [Countries2]),
\end{example}

В универсальном варианте предиката zagz используются
weak-варианты функций - они просто игнорируют те поля, которые
отсутствуют в объекте. Это позволяет использовать объекты в любых
сочетаниях, например:

\begin{example}{}{}
?- obj_construct(man_v, [sex, name, surname], 
      [man, 'Robert', 'Schumann'], A), 
   obj_construct(citizen_v, [sex, name, surname, country], 
      [woman, 'Oksana', 'Mazur', ['Ukraine']], B), 
   zagz(A, B, _, A2, B2), 
   obj_pretty_print(A2), 
   obj_pretty_print(B2).

man_v ( 
  sex : man 
  name : Robert 
  surname : Schumann 
) 
citizen_v ( 
  sex : woman 
  name : Oksana 
  surname : Schumann 
  country : [Ukraine] 
) 
\end{example}

то есть, как говорится, каждому своё. Оксане изменили фамилию, но
Роберту страну не добавили, поскольку мы не рассматривали Шумана
в гражданской плоскости.

Концепция написания универсальных предикатов может показаться
неожиданной тому, кто привык оперировать методами объекта. Но
причина в том, что в \ur{} объект - это прежде всего объект
наблюдения. А у объекта наблюдения нет методов, только
свойства. Получив какой-либо объект в виде, допустим, man_v, мы
не можем быть уверены, что за ним не скрывается citizen_v. И
поэтому в \ur{} существует такое понятие, как вычисление
класса и даункаст.

Но прежде, чем рассмотреть такую важную концепцию, как даункаст,
давайте исследуем мир вычислимых полей.
\end{comment}

\section{Вычислимые поля}

Не все атрибуты объекта имеет смысл задавать, некоторые можно
вычислить на основе других атрибутов или полей. В терминах
\ur{} такие атрибуты называются вычислимыми полями. Например,
возраст гражданина можно задать, как разность между текущем годом
и годом рождения. Текущий год определим с помощью предиката
get_time/1, возвращающего текущее время. 

\begin{example}{}{}
:- module(citizen_v, []).

'citizen_v?'(Term, age, Age) :-

        obj_field(Term, birthday, Birthday),
        (  number(Birthday)
        -> get_time(TS),
           stamp_date_time(TS, DT, local),
           date_time_value(year, DT, Current_Year),
           Age is Current_Year - Birthday
        ;
           true
        ).
        
new_class(citizen_v, man_v, [country, id, birthday]).
\end{example}

\verb|'citizen_v?'| задаёт вычислимое поле. Данный предикат
никогда не будет вызываться напрямую. Это служебный
предикат. Его имя содержит знак вопроса и поэтому, по синтаксису
Пролога, пишется в одинарных кавычках.

Для программы, использующей объектную модель \ur, вычислимые 
поля на операциях чтения не будут отличаться от обычных.

\begin{example}{}{}
?- obj_construct(citizen_v, [birthday], [1976], C), 
   obj_field(C, age, Age), 
   obj_pretty_print(C).

citizen_v ( 
  birthday : 1976 
  age : 37 
) 
\end{example}

Однако вы не можете присвоить значение, если не доработаете
служебный предикат. Вот как можно его видоизменить, чтобы иметь
возможность читать и писать поле возраста:

\begin{example}{}{}
'citizen_v?'(Term, age, Age) :-

        get_time(TS),
        stamp_date_time(TS, DT, local),
        date_time_value(year, DT, Current_Year),
        
        obj_field(Term, birthday, Birthday),
        (  number(Birthday)
        -> Age is Current_Year - Birthday
        ;  number(Age)
        -> Birthday is Current_Year - Age
        ;  true % leave both Age and Birthday unbound
        ).
        
\end{example}

Обратите внимание, мы всегда проверяем тип данных и связанность полей, на
основе которых определяем значения вычислимых полей. Если исходные поля не
пригодны для определения значения, принято оставлять вычислимое поле не
связанным.

Стоит ещё добавить, что правило вычисления поля может быть
переопределено в потомке, потому отдалённо может рассматриваться
как виртуальная функция. Более того, объект object_v, от
которого принято наследовать все остальные объекты, уже имеет два
вычислимых поля - class и functor. При этом functor - это всегда
имя объекта, как предиката, например, citizen_v. По правилам, он
не может перекрываться в потомке. Что касается class, то, по
умолчанию, значение этого поля совпадает с functor, но
... Впрочем, этому посвящена отдельная глава.


\section{Downcast или путешествие вниз по лестнице наследования}
\label{downcast}

Вернёмся теперь к вопросу наследования. Введём новый объект -
военнообязанный.

\begin{example}{}{}
:- module(callup_v, []).

new_class(callup_v, citizen_v, [fit_for_military_service]).
\end{example}

Вероятно, есть правило, по которым гражданин считается
военнообязанным. Допустим оно звучит так: мужчина от 18 до 25
лет. Но сложность заключается в том, что citizen_v становится
военнообязанным не в силу создания как callup_v, а в силу
удовлетворения этим условиям. Более того, военнообязанность может
наступить автоматически при достижении призывного
возраста. Иными словами, мало кто создаётся как
военнообязанный. Это получается как-то само-собой.

Рассмотрим такое определение класса в модуле citizen_v\footnote{Если класс
  callup_v предполагается разместить в другом модуле, то с точки зрения
  хорошего стиля, первый из этих предикатов следует переместить в модуль, где
  определён callup_v.}:

\begin{example}{}{}
'citizen_v?'(Term, class, callup_v) :-
        obj_field(Term, sex, Sex),
        Sex == man,
        obj_field(Term, age, Age),
        between(18, 25, Age), !.

'citizen_v?'(Term, class, citizen_v) :-
        \+ 'citizen_v?'(Term, class, callup_v).
\end{example}

% Объяснить, почему Sex == man

По сравнению с предыдущим, мы добавили правила вычисления class,
переопределив правило его вычисления из object_v. Это даёт такой
результат:

\begin{example}{}{}
?- obj_construct(citizen_v, [sex, birthday], [man, 1976], C), 
   obj_field(C, class, Class).

C = citizen_v(11, 1976, _G1685, _G1686, _G1687, _G1688, man, _G1690, _G1691),
Class = citizen_v.

?- obj_construct(citizen_v, [sex, birthday], [man, 1995], C), 
   obj_field(C, class, Class).

C = citizen_v(11, 1995, _G1685, _G1686, _G1687, _G1688, man, _G1690, _G1691),
Class = callup_v.
\end{example}

Результат, как говорится, на лицо.

Однако определить значение класса - это пол дела. Принадлежность
классу у нас определяется ещё набором полей, как вычислимых так и
обычных. Мы не можем задать объекту citizen_v значение поля
fit_for_military_service:

\begin{example}{}{}
?- obj_construct(citizen_v, [sex, birthday], [man, 1995], C),                            
   obj_field(C, fit_for_military_service, yes).
ERROR: obj_field/3: Unknown error term: no_object_field(citizen_v(11,1995,_G2188,_G2189,_
G2190,_G2191,man,_G2193,_G2194),fit_for_military_service)                               
\end{example}

Потому как объект сконструирован с термом citizen_v

\begin{example}{}{}
?- obj_construct(citizen_v, [sex, birthday], [man, 1995], C), 
   C / [class,functor] ^= L.

C = citizen_v(11, 1995, _G2673, _G2674, _G2675, _G2676, man, _G2678, _G2679),
L = [callup_v, citizen_v].
\end{example}

о чём говорит то самое непереопределяемое поле functor.

Очевидно, для полного превращения гражданина в военнообязанного
(не по факту, а по возможности использования дополнительных полей
в программе) надо каким-то образом привести в соответствие класс
и функтор.

\begin{example}{}{}
?- obj_construct(citizen_v, [sex, birthday], [man, 1995], C), 
   C / [class,functor] ^= Type1,
   obj_downcast(C, M),
   M / [class,functor] ^= Type,
   obj_field(M, fit_for_military_service, yes).

C = citizen_v(11, 1995, _G2858, _G2859, _G2860, _G2861, man, _G2863, _G2864),
Type1 = [callup_v, citizen_v],
M = callup_v(12, 1995, _G2858, yes, _G2859, _G2860, _G2861, man, _G2863, _G2864),
Type = [callup_v, callup_v].
\end{example}

Ответ Пролога говорит о том, что мы достигли
результата с помощью предиката obj_downcast/2.

Существует также триарная форма obj_downcast, которая выполняет
преобразование к заданному типу ``насильно'' (не взирая на поле class). 

\begin{comment}
Например, возвращаясь к примеру
Шуман-Мазур, нам бы достаточно было бы написать так:

\begin{example}{}{}
?- obj_construct(man_v, 
      [sex, name, surname], 
      [man, 'Robert', 'Schumann'], A), 

   obj_construct(citizen_v, 
      [sex, name, surname, country], 
      [woman, 'Oksana', 'Mazur', ['Ukraine']], B), 

   obj_downcast(A, citizen_v, AC),

   zagz(AC, B, _, A2, B2), 

   obj_pretty_print(A2), 
   obj_pretty_print(B2).

citizen_v ( 
  sex : man 
  name : Robert 
  surname : Schumann 
  country : [Ukraine] 
) 
citizen_v ( 
  sex : woman 
  name : Oksana 
  surname : Schumann 
  country : [Ukraine] 
) 
\end{example}

чтобы сделать Роберта Шумана гражданином Украины.
\end{comment}

\subsection{Неожиданный поворот событий в связи с унификацией}

До сих пор влияние унификации на объекты было очевидным. Это было
связано с тем, что мы всегда её контроллировали, унифицируя
объекты с переменными с помощью \verb|`^='|, либо дублируя объект
посредством obj_rewrite. 

Однако, obj_downcast неявно вводит ещё унификацию между родителем и потомком:

\begin{example}{}{}
?- obj_construct(man_v, 
      [sex, name, surname], 
      [man, 'Robert', 'Schumann'], A), 
   obj_downcast(A, citizen_v, AC),
   obj_field(AC, weight, 72).

A = man_v(10, _G3139, 'Robert', man, 'Schumann', 72),
AC = citizen_v(11, _G3197, _G3198, _G3139, _G3200, 'Robert', man, 'Schumann', 72).
\end{example}

Итак, A и AC --- это разные представления {\bf одного и того же}
объекта.

\section{Upcast или путешествие вверх по лестнице наследования}
\label{upcast}

Для выполнения upcast в \ur{} нет специально выделенного
предиката. Но при необходимости, upcast можно просто реализовать
на базе следующих предикатов:

\begin{itemize}
\item \verb|class_fields/2|
\item \verb|object_construct/4|
\item \verb|^=/2|
\end{itemize}

% аналог class_fields для вычислимых полей

При освоении предыдущего материала данный вопрос не должен
вызвать затруднение у читателя. Оставим реализацию функции
obj_upcast на самостоятельную проработку. 
%Будет ли она относится
%к не развязывающему семейству, как и obj_downcast?

\section{Сравнение объектов}
\label{obj_diff}

Часто (особенно, в процессе написания автоматических тестов)
необходимо сравнивать объекты. Для этого предназначен предикат
\verb|obj_diff/3|:

\begin{example}{Сравнение двух объектов}{obj_diff_sample}
?- obj_construct(man_v, 
      [sex, name, surname, weight], 
      [women, 'Clara', 'Wieck', 62], Obj1), 
   
   obj_construct(citizen_v, 
      [sex, name, surname, weight, country], 
      [women, 'Clara', 'Schumann', 72, 'Germany'], Obj2), 

   obj_diff(Obj1, Obj2, Diff).

Diff = [diff(weight, 62, 72), diff(surname, 'Wieck', 'Schumann'), diff(country, _G51, ['Germany'])].
\end{example}

%Как видно, он умеет сравнивать также вычислимые поля.

% На самом деле только те, что присутствуют в object_v.

Результат можно напечатать в удобочитаемой форме с помощью
\verb|obj_diff_print|:

\begin{example}{}{}
?- ..., obj_diff_print(Diff).

( 
  country : _G14 -> [Germany] 
  surname : Wieck -> Schumann 
  weight : 62 -> 72 
) 
\end{example}

\section{Копирование объектов}
\label{obj_copy}

При рассмотрении, в частности, предиката \ref{obj_downcast} мы столкнулись с
тем, что значения, на первый взгляд, разных объектов могут оставаться {\it
  связанными\/} (в этом случае мы говорили о разных {\it видах} одного и того
же объекта). Для того, чтобы принудительно {\it отвязать\/} объект от
производного от него нужно использовать предикат obj_copy. 
%У него есть две формы:

\begin{example}{obj_copy/2}{obj_copy/2_sample}
?- obj_construct(man_v, 
      [sex, name, surname], 
      [man, 'Robert', 'Schumann'], A), 

   obj_copy(A, A2), 
   obj_field(A2, weight, 72).                     

A = man_v(10, _G3137, 'Robert', man, 'Schumann', _G3141),
A2 = man_v(10, _G3151, 'Robert', man, 'Schumann', 72).
\end{example}

\begin{comment}
и 

\begin{example}{obj_copy/3}{obj_copy/3_sample}
?- obj_construct(man_v, 
      [sex, name, surname], 
      [man, 'Robert', 'Schumann'], A), 
    
   obj_copy([sex, name], A, A2),                              
   obj_field(A2, weight, 72).

A = man_v(man, 'Robert', 'Schumann', _G18, _G19),
A2 = man_v(man, 'Robert', _G131, 72, _G133).
\end{example}

Внимательный читатель заметит, что предикат obj_copy/3 является
как-бы инверсией obj_reset_fields/3 с тем лишь отличием, что в
первом перечисляются поля, которые необходимо сохранить, а во
втором - которые необходимо очистить. А obj_copy/2 эквивалентен
вызову obj_reset_fields/3 с пустым списком полей. Однако это не
так.

\subsection{Объекты со сложной семантикой копирования}
\label{limited_types}

(пример со странами и гражданами)

\section{Поля с типами}

....
\section{Формат файла-определения объекта}
\label{object_file_format}

\end{comment}

% _v? predicated
% copy/3
% typedef/2
% downcast/4

\begin{comment}
\chapter{Объектная база данных}
\label{ur_recorded_db}

\section{Понятие объектной базы}

В программировании и науке о программах термин ``объектная база
данных'' используется достаточно давно, так что он успел обрасти
различными значениями. По этой причине мы сразу оговоримся, что
мы понимаем под объектной базой данных в \ur. Прежде всего,
объектная база данных \ur - это прологовская база термов. Но
мы никогда не будем обращаться к ней как к базе данных термов, а
только как к базе данных уран-объектов. Это предполагает, что
операции Урана скрывают низкоуровневый доступ к прологовской базе
как базе термов - раз, дополняют концепцию базы, как хранилища,
применительно к объектов - два и дополняют саму концепцию
объектов, изложенную в предыдущей главе - три.

Но прежде чем окунуться в новые концепции (а если точнее -
расширить ту концепцию понимания объектов, которая была изложена
в предыдущей главе), давайте вкратце рассмотрим расширенную базу
термов языка Пролог.
 
\section{Расширенная база термов}

Под ``расширенной базой термов'' мы будем понимать некоторое
расширение ISO стандарта языка. 

Как известно (изложено в литературе [1]), стандартными операциями
с базой даных Пролога являются предикаты  assert(+Term),
asserta(+Term), assertz(+Term) - для добавления терма в базу,
retract(+Term) - для удаления терма и обычная унификация для
извлечения объектов. То есть, стандартная база данных Пролога -
это то же самое, что и сама программа. По этой причине она очень
не эффективна, так как после операции retract нам нужно
перекомпилировать всю программу, чтобы избавиться от её
зависимостей от удалённого терма.

По этой причине рядом реализаций предложена расширенная база
данных (в английском языке используется термин ``recorded data
base''). В частности, такая реализация присутствует SWI Prolog.

Рассмотрим подробнее.

В отличие от стандартной базы данных Пролога расширенная не видна
программе в унификации, а потому не требует перекомпиляции всех
предикатов. Точнее, конечно, унификация присутствует, но при
унификации мы всегда говорим, с каким именно ключём происходит
унификация. В простейшем случае ключ - это атом. Так как
используется ключ, то стандартная унификация не видит термы,
спрятанные за ``замком'' и более того, имея один ключ мы видим
только термы, спрятанные с помощью него.

Рассмотрим пример.

\begin{example}{}{}
?- recordz(key1, full_name('Robert', 'Schumann')).
true.

?- recordz(key1, full_name('Clara', 'Wieck')).
true.

?- recordz(key2, full_name('Oksana', 'Mazur')).
true.

?- recordz(key2, full_name('Shura', 'Buravin')).
true.

?- recorded(key1, X).
X = full_name('Robert', 'Schumann') ;
X = full_name('Clara', 'Wieck').

?- recorded(key1, full_name('Clara', Surname)).
Surname = 'Wieck'.

?- recorded(key2, full_name('Clara', Surname)).
false.

?- recorded(key2, full_name(Name, Surname)).
Name = 'Oksana',
Surname = 'Mazur' ;
Name = 'Shura',
Surname = 'Buravin'.
\end{example}

Как видим, ключи разбивают одну физическую базу на много
логических баз. Но мы всегда можем думать о них, как о различных
базах.

Для удаления записей используется предикат erase/1.

Отметим одну важную особенность, которая будет видна при
рассмотрении всех низкоуровневых предикатов доступа к базе. Термы
(объекты) прологовской базы всегда упорядочены в том порядке,
который задаётся при их вставке. Как правило мы используем
вставку в конец. Поэтому, при извлечении, порядок объектов будет
определяться порядком их вставки (при использовании прологовской
базы).

\section{База данных \ur}

Как уже говорилось, мы не будем использовать recorded database
напрямую. Более того, лучше не думать о recorded database
конкретной реализации пролога. Нам важна концепция. О способах
реализации данной концепции в \ur{} ещё будет сказано --- вообще
говоря, она не обязана вообще использовать прологовскую базу.

Итак, для работы с объектной базой \ur{} необходимо загрузить
модуль lib(ur_recorded_db). Вот основные предикаты модуля

\begin{description}
\item \verb|db_put_object(+DB_Key, +Object, -Object1)| поместить объект в
  базу (\ref{db_put_object/3})
%db_put_objects/4. % +DB_Key, :Pred, +Options
\item \verb|db_recorded(+DB_Key, ?Term)| унифицировать Term с
  базой (\ref{db_recorded/2})
%db_recorded(+DB_Key, ?Term, -DB_Ref)
\item \verb|db_bind_obj(+DB_Key, +Obj0, -Obj)| унифицировать
  термы в базе с Term (\ref{db_bind_obj})

%db_erase_object(+DB_Key, +Key, +Key_Value)
\item \verb|db_erase(+DB_Ref)| удалить объект по физическому
  адресу (\ref{db_erase})

\item \verb|db_iterate(+DB_Key, +Query, -Object)| извлечь объект
  из базы, используя Query (\ref{db_iterate/3})
\item \verb|db_iterate(+DB_Key, +Query, :Filter_Pred, -Object)|
  дополнительно фильтровать записи с помощью Pred/1
\item \verb|db_iterate_replace(+DB_Key, :Pred, +Query)| с помощью
  предиката \verb|Pred(+Obj_In, -Obj_Out, -Is_Succ)| провести
  замену всех объектов, удовлетворяющих Query
  (\ref{db_iterate_replace/3})
\item
  \verb|db_iterate_replace(+DB_Key, :Pred, +Query, :Filter_Pred)|
  дополнительная фильтрация Query с помощью Filter_Pred/1,
  аналогично db_iterate/4
\item
  \verb|db_iterate_replace(+DB_Key, :Pred, :Filter_Pred, +Query, +Lim)|
  аналогично db_iterate_replace/4, но заменить не более Lim
  объектов
\item \verb|db_reset(+DB_Key, +Reset_List, +Query)| сброс полей
  Reset_List объектов, удовлетворяющих Query в базе DB_Key (\ref{db_reset})
\item \verb|db_change(+DB_Key, +Fields, +Values, +Query)|
  изменение значений полей 
% (проблема уже связанных переменных)
%  \begin{example}{}{}
%  (some way)  db_change(links_l, [http_request_url, timestamp],
%    [A, A], true). 

%   db_change(links_l, [http_request_url, timestamp], [a, b],
%   true). - false

%   db_change(links_l, [http_request_url, timestamp], [a, a],
%   true). - true

%   (может быть более общая проблема - отсутствие флага
%   обработанных записей?)
%  \end{example}

\item \verb|db_object_class(+DB_Key, ?Class)| определение всех
  функторов для предикатов, хранящихся в базе
  (\ref{db_object_class})

\item \verb|db_size(+DB_Key, ?N)| определение количества записей
\item \verb|clear_db(+DB_Key)| очистить базу (\ref{clear_db})
\item \verb|filter_on_db(+DB_Key, +Field_Names, +Field_Values)|
  профильтровать базу - оставить только унифицированные объекты
  (\ref{filter_on_db})
\item \verb|db_copy(+DB_In, +DB_Out)| копирование всех записей из
  одной базы в другую (\ref{db_copy})
\item \verb|db_search(+DB_In, +DB_Out, :Pred)| копирование только
  тех записей, для которых Pred вычисляется в true
  (\ref{db_search})
%db_move_all_data
\item \verb|dump_db(+DB_Key)| отладочная печать содержимого базы
  (\ref{dump_db})
%db_merge
\end{description}


\section{Добавление и чтение объектов (db_put_object/3,
  db_i:db_recorded/2)}
\label{db_put_object/3}
\label{db_recorded/2}

db_put_object помещает объект в базу DB_Key, db_recorded -
читает (унифицирует) объект

% ныне db_recorded - скрытый (internal) предикат, а db_put_object
% - получил 3-й аргумент (объяснить)

% возможно надо добавить главу про rebasing. Рассказать на
% примерах, зачем он нужен

\begin{example}{База people}{people_db}
?- obj_construct(man_v, 
      [sex, name], 
      [man, 'Adam'], Man), 
   db_put_object(people, Man, _).

?- obj_construct(man_v, 
      [sex, name], 
      [woman, 'Eva'], Man), 
   db_put_object(people, Man, _).

?- db_i:db_recorded(people, X).
X = man_v(43, recorded(<record>(0xe4ef80)), _G305, 'Adam', man, _G308, _G309) ;
X = man_v(44, recorded(<record>(0xe4ff80)), _G10, 'Eva', woman, _G13, _G14).

?- obj_construct(citizen_v, 
      [sex, surname, country], 
      [man, 'Mayakovsky', ['Soviet Union']], Man), 
   db_put_object(people, Man, _). 

?- db_i:db_recorded(people, X).
X = man_v(43, recorded(<record>(0xe4ef80)), _G120, 'Adam', man, _G123, _G124) ;
X = man_v(44, recorded(<record>(0xe4ff80)), _G120, 'Eva', woman, _G123, _G124) ;
X = citizen_v(46, recorded(<record>(0xe53d20)), _G120, _G121, man, 'Mayakovsky', _G124, _G125, ['Soviet Union'], _G127).
\end{example}

% подправить этот абзац (не ясно о наследовании и rebased)
как видите, в базу можно помещать разные объекты. И в самом деле
- это просто термы Пролога. Сама база ничего не знает об их
взаимосвязи, например, о наследовании.

Для того, чтобы проиллюстрировать это на примере, давайте сначала
перейдём к более компактной форме отображения с помощью
obj_pretty_print. 

\begin{example}{Печать всех объектов базы}{all_db_print}
?- db_recorded(people, X), 
   obj_pretty_print(X), 
   fail ; true.

man_v ( 
  sex : man 
  name : Adam 
) 
man_v ( 
  sex : woman 
  name : Eva 
) 
citizen_v ( 
  sex : man 
  surname : Mayakovsky 
  country : [Soviet Union] 
) 
true.
\end{example}

(Здесь использован довольно часто употребляемый pattern Пролога -
цикл с перебором всех решений. fail заставляет искать очередной
вариант решения db_recorded после печати объекта, а после того,
как все варианты будут перебраны, управление пойдёт по второй
ветке, и предикат вернёт true.)

% Это всё неправда в связи с rebasing

\section{Унификация объектов ``в лоб''}

Как, в данном случае, организовать не вычитку объектов а
унификацию, то есть сопоставление полей, например, как найти всех
мужчин в базе people? Можно, вспомнив, что под базой объектов
\ur{} всегда лежит база термов, попытаться использовать
``запрещённый приём'' (обращение к объекту как к терму), но в
скрытой, и, как будто-бы, благопристойной форме:

\begin{example}{}{}
?- obj_construct(man_v, [sex], [man], X), 
   db_recorded(people, X).

X = man_v(man, 'Adam', _G1109, _G1110, _G1111) ;
false.
\end{example}

Как видите, с man_v унифицируется только man_v. Аналогично
будет с citizen_v:

\begin{example}{}{}
?- obj_construct(citizen_v, [sex], [man], X), 
   db_recorded(people, X).

X = citizen_v(man, _G9, 'Mayakovsky', _G11, _G12, ['Soviet Union'], _G14, _G15).
\end{example}

Вот тут на помощь и приходит семейство предикатов named_arg* .

\section{Семейство унификаторов named_args_unify}
\label{named_arg_db}

\na{} --- это семейство унификаторов по именованным
полям. 

named_args_unify(+DB_Key, ?Functor, +Field_Names, ?Values, ?Term)

унифицирует объект по списку полей и функтору. Если
функтор не определён, то проявляется полиморфизм

\begin{example}{Поиск мужчин}{find_men}
?- named_args_unify(people, Functor, [sex], [man], Man).

Functor = man_v,
Man = man_v(man, 'Adam', _G24, _G25, _G26) ;

Functor = citizen_v,
Man = citizen_v(man, _G37, 'Mayakovsky', _G39, _G40, ['Soviet Union'], _G42, _G43) 
\end{example}

естественно, Value тоже можно опустить, и тогда

\begin{example}{Поиск по половому признаку}{find_sex}
?- named_arg_unify(people, Functor, sex, V, Man).

Functor = man_v, V = man, Man = man_v(man, 'Adam', _G31, _G32,
 _G33) ;

Functor = man_v, V = woman, Man = man_v(woman, 'Eva', _G31, _G32,
 _G33) ;

Functor = citizen_v, V = man, Man = citizen_v(man, _G44,
 'Mayakovsky', _G46, _G47, ['Soviet Union'], _G49, _G50)
\end{example}

мы получим всех.

Как и для объектов-значений, рассматривавшихся в разделе
(ur_objects), существует возможность использовать несколько
полей для унификации:

\begin{example}{}{}
?- named_args_unify(people, Functor, [name, surname], 
                    [N, S], Obj),
   (nonvar(N) -> Name = N; Name = '?'), 
   (nonvar(S) -> Surname = S; Surname = '?'), 
   format("~w ~w~n", [Name, Surname]), 
   fail; true.
      
Adam ?
Eva ?
? Mayakovsky
\end{example}

мы напечатали имена и фамилии, при этом, неопределённые поля
заменили вопросами. \verb|nonvar/1| позволил отличить
неопределённые поля от определённых, однако, данный метод очень
зависит от порядка унификации. К примеру, если попытаться найти
всех Адамов, то, как и следует ожидать, неопределённые поля
унифицируются до проверки \verb|nonvar|:

\begin{example}{Поиск Адамов}{adam_mayakovsky}
?- N='Adam', 
   named_args_unify(people, Functor, [name, surname], 
                    [N, S], Obj), 
   (nonvar(N) -> Name = N; Name = '?'), 
   (nonvar(S) -> Surname = S; Surname = '?'), 
   format("~w ~w~n", [Name, Surname]), fail; true.
                                                              
Adam ?
Adam Mayakovsky
\end{example}

Т.о., можно сказать, что предикаты \na{} являются
не очень совершенным методом работы с базой объектов и могут
рассматриваться только как низкоуровневые предикаты. При их
использовании мы сталкиваемся со следующими проблемами:

\begin{itemize}
\item[1)] Нельзя указать, что поле несвязано. Можно только
  протестировать значение в каком-то месте выражения, что
  чувствительно к порядку предикатов и
\item[2)] Унификация простирается только на переменные и объекты в
  выражении. При связывании поля name с именем Adam значения в
  базе остались не изменными. Т.о., унификация здесь
  односторонняя.
\end{itemize}

В дальнейшем мы покажем, как решаются эти проблемы с помощью
предикатов модуля ur_recorded_db. Сейчас дадим ещё несколько
базовых (низкоуровневых) предикатов.

\subsection{Паровозики из \na}

...

\section{Удаление объектов из базы по физическим адресам
  (db_erase)}
\label{db_erase}
\label{db_copy}

% Переписать!

Для удаления объекта из базы его необходимо, для начала,
найти. Пока нам известно только два способа поиска объекта -
db_recorded и named_arg*. Однако, можно сказать, что независимо
от способа поиска удаление всегда идёт по следующему сценарию

\begin{enumerate}
\item Мы должны найти некий идентификатор объекта в базе.
\item Мы должны передать этот идентификатор в предикат удаления
  объекта db_erase.
\end{enumerate}

Идентификатор объекта в базе --- это либо, \tn, физический адрес,
либо ключ. Ключи - это большая концепция, она будет рассмотрена в
разделе \ref{keys}, здесь же рассмотрим удаление объектов по их
физическому адресу.

При этом, под физическим адресом будем понимать непрозрачный
идентификатор, используемый конкретной реализацией базы. При этом
модуль ur_recorded_db использует такую структуру физического
адреса, которая однозначно идентифицирует и саму базу и
конкретную запись в ней. То есть, при использовании различных баз
физический адрес всегда получается связан с той базой, для
которой он получен и, при удалении объекта, нет надобности
ссылаться на базу.

Например

\begin{bigexample}{Удаление объектов по физическим адресам}%
               {db_erase_example}
?- db_copy(people, people1).
true.

?- db_copy(people, people2).
true.

?- findall(Ref, 
           named_arg_unify(people1, citizen_v, name, _, _, Ref), 
           Ref_List1), 
   findall(Ref, 
           named_arg_unify(people2, man_v, name, _, _, Ref), 
           Ref_List2), 
   append(Ref_List1, Ref_List2, Ref_List), 
   !, 
   (member(Ref, Ref_List), db_erase(Ref), fail; true).

Ref_List1 = [recorded(<record>(0x2134e18))],

Ref_List2 = [recorded(<record>(0x2134d20)), 
             recorded(<record>(0x2134d58))],

Ref_List = [recorded(<record>(0x2134e18)), 
            recorded(<record>(0x2134d20)), 
            recorded(<record>(0x2134d58))].

?- db_recorded(people1, T).
T = man_v(man, 'Adam', _G304, _G305, _G306) ;
T = man_v(woman, 'Eva', _G304, _G305, _G306).

?- db_recorded(people2, T).                                        
T = citizen_v(man, _G303, 'Mayakovsky', _G305, _G306, 
              ['Soviet Union'], _G308, _G309).
\end{bigexample}

Рассмотрим пример подробно.

\begin{enumerate}
\item C помощью предиката db_copy/2 создаём две полные копии базы
  people - people1 и people2.
\item С помощью findall и named_arg_unify/6 находим все объекты
  с функтором citizen_v в базе people1 и складываем их
  физические адреса в Ref_List1. Аналогично для базы people2
  находим объекты man_v и формируем Ref_List2.
\item Объединяем два списка физических адресов.
\item Удаляем найденные объекты.
\item Делая запросы к базам people1 и people2 убеждаемся в том,
  что people1 очищена от объектов citizen_v, а people2 --- от
  man_v.
\end{enumerate}

Следует в очередной раз подчеркнуть, что построение списка по
базе --- операция крайне неэффективная, если размер этих списков
никак не ограничен. В данном случае, мы использовали этот приём
только для того, чтобы показать связанность адреса с ``его''
базой после смешивания всех адресов в одном списке.

\section{Печать содержимого базы (dump_db)}
\label{dump_db}

В примере \ref{db_erase_example} мы использовали откат для
распечатки содержимого базы. Модуль ur_recorded_db определяет
предикаты dump_db, которые можно использовать для отладочной
распечатки.

\begin{example}{}{}
?- [logging/logging].
% logging/logging compiled into logging 0.01 sec, 2,168 bytes
true.
\end{example}

(проинициализировали систему отладочной печати)

\begin{example}{}{}
?- dump_db([], people1).

[1]: Dump the people1 DB:  :[logging]
[2]: man_v(man,Adam,_G84,_G85,_G86) man_v(woman,Eva,_G84,_G85,_G86)
  :[logging]                                                      

?- dump_db([], people2).

[3]: Dump the people2 DB:  :[logging]
[4]: citizen_v(man,_G83,Mayakovsky,_G85,_G86,[Soviet Union],_G88,_G
89)  :[logging]                                                   
\end{example}

Первый аргумент предиката dump_db/2 задаёт список опций
(см. \ref{logging}). Например, для вывода каждой записи базы на
новой строке необходимо добавить опцию \verb|lf(1)|.

\section{Очистка базы (clear_db)}
\label{clear_db}

Для очистки всей базы существует предикат clear_db/1:

\begin{example}{}{}
?- clear_db(people1), clear_db(people2), 
   dump_db([], people1), dump_db([], people2).                                                         

[5]: Dump the people1 DB:  :[logging]
[6]:  :[logging]

[7]: Dump the people2 DB:  :[logging]
[8]:  :[logging]
true.
\end{example}

\section{Классовая фильтрация (class_descendant)}
\label{class_descendant}

Давайте теперь возвратимся к примерам \ref{find_men} и
\ref{find_sex}. Как быть, если в базе не будет объекта, имеющего
поле sex или будет, но не производный от man_v? Ответ прост ---
если поля нет, то объект по полю sex унифицирован не будет (не
будет выбран), если есть - то будет.

Давайте рассмотрим пример. Допустим, мы хотим хранить в базе
также мужские и женские шампуни:

\begin{example}{shampoo_v определение}{shampoo_v}
:- module(shampoo_v, []).

new_class(shampoo_v, object_v, [name, firm, sex]).
\end{example}

(создали новый модуль)

\begin{example}{}{}
?- obj_construct(shampoo_v, [firm, sex], 
                 ['Schwarzkopf', man], Obj),
    db_put_object(people, Obj, _).
\end{example}

(добавили объект)

\begin{example}{}{}
?- named_arg_unify(people, Functor, sex, man, Obj), 
   obj_pretty_print(Obj), fail; true.

man_v ( 
  sex : man 
  name : Adam 
) 
citizen_v ( 
  sex : man 
  surname : Mayakovsky 
  country : [Soviet Union] 
) 
shampoo_v ( 
  firm : Schwarzkopf 
  sex : man 
) 
\end{example}

А как быть, если нас интересуют только потомки man_v?

Это можно решить, используя дополнительный предикат:

\begin{example}{}{}
?- named_arg_unify(people, Functor, sex, man, Obj), 
   (Functor = man_v ; class_descendant(man_v, Functor)), 
   obj_pretty_print(Obj), fail; true.

man_v ( 
  sex : man 
  name : Adam 
) 
citizen_v ( 
  sex : man 
  surname : Mayakovsky 
  country : [Soviet Union] 
) 
\end{example}

Выражение
\verb|Functor = man_v ; class_descendant(man_v, Functor)|
означает: когда класс (функтор) равен man_v или является
потомком man_v. Т.о., в данном примере, named_arg_unify будет
возращать все записи, для которых поле sex = man, а данное
выражение - пропускать только те, которые имеют соответствующий
класс. 

Можно, однако, составить эквивалентный, но более эффективный
запрос, поменяв порядок предикатов:

\begin{example}{Все мужчины}{all_men_print}
?- (Functor = man_v ; class_descendant(man_v, Functor)), 
   named_arg_unify(people, Functor, sex, man, Obj), 
   obj_pretty_print(Obj), fail; true.

man_v ( 
  sex : man 
  name : Adam 
) 
citizen_v ( 
  sex : man 
  surname : Mayakovsky 
  country : [Soviet Union] 
) 
\end{example}

Вопрос о том, почему данный запрос является более эффективным,
оставим читателю на самостоятельную проработку.

Вообще же, для большей эффективности запросов, следует стараться
разделять базы и не хранить шампуни в базе people, чтобы не
прибегать часто к классовой фильтрации.

\section{Получение всех классов (db_object_class)}
\label{db_object_class}

Иногда необходимо перебрать все классы, находящиеся в базе. Для
этого предназначен предикат db_object_class:

\begin{example}{}{}
?- db_object_class(people, X).

X = man_v ;
X = citizen_v ;
X = shampoo_v.
\end{example}

\section{Двусторонняя унификация с базой}
\label{db_bind_obj}

В разделе \ref{named_arg_db} было сказано, что унификация с
помощью предикатов \na{}, несмотря на то, что выполняется между
объектами базы и выражения, связывает переменные только в
объектах выражения. А что, если мы хотим заставить работать
унификацию ``в сторону базы''? \Te, например, усвоить всем
мужчинам с фамилией Маяковский имя Владимир:

(в этом разделе мы будем работать с базой people, созданной в
примере \ref{people_db}).

\begin{example}{Называние всех Маяковских Владимирами}%
               {vladimir_to_all_mayakovsky}
?- clear_db(people1), db_copy(people, people1).
true.

named_args_unify(people1, _, 
      [sex, surname], [man, 'Mayakovsky'] , Man1), 
   obj_field(Man1, name, 'Vladimir'), 
   db_bind_obj(people1, Man1, Man).

?- dump_db([lf(1)], people1).

[5]: man_v(man,Adam,_G2487,_G2488,_G2489) 
man_v(woman,Eva,_G2487,_G2488,_G2489) 
citizen_v(man,Vladimir,Mayakovsky,_G2488,_G2489,[Soviet Union],_G24
91,_G2492)                                                        
 :[logging]
\end{example}

Нетрудно видеть, что унификация состаялась.

Следует отметить, что мы не можем обращаться напрямую к полям
объектов базы, \te, obj_field и \na{} не только работают ``в
сторону выражения'', но и не имеют прямых аналогов для работы в
другую сторону. Связывание несвязанных полей для объектов базы
всегда выполняется по схеме:

\begin{enumerate}
\item Получить связанный объект в выражении.
\item Унифицировать его с объектом в базе.
\end{enumerate}

Пункт 1 подразумевает, что мы, каким-то образом, получили в
выражении объект с тем же функтором, что в базе и провели
унификацию сначала над ним. Пункт 2 необходимо пояснить. Дело в
том, что унификация bind_term_in_db работает, на самом деле, в
две стороны. Это показано в следующем примере:

\begin{example}{}{}
?- clear_db(people1), db_copy(people, people1).
true.

?- named_args_unify(people1, _, 
      [sex, surname], [man, 'Mayakovsky'] , Man), 

   obj_field(Man, name, 'Vladimir'), 
   obj_reset_fields([surname], Man, Man1), 
   obj_pretty_print(Man1), 
   db_bind_obj(people1, Man 1), 
   obj_pretty_print(Man1).

citizen_v ( 
  sex : man 
  name : Vladimir 
  country : [Soviet Union] 
) 
citizen_v ( 
  sex : man 
  name : Vladimir 
  surname : Mayakovsky 
  country : [Soviet Union] 
) 

?- dump_db([lf(1)], people1).
[7]: man_v(man,Adam,_G2487,_G2488,_G2489) 
man_v(woman,Eva,_G2487,_G2488,_G2489) 
citizen_v(man,Vladimir,Mayakovsky,_G2488,_G2489,[Soviet Union],_G2491,_G2492)                                                        
 :[logging]
\end{example}

Мы сначала нашли объект с фамилией 'Mayakovsky', затем связали
имя, но сбросили поле фамилии, затем унифицировали с базой, в
результате чего имя перешло в базу а фамилия --- в
выражение. Переменная Man1 была распечатана дважды --- до вызова
db_bind_term_in_db и после.

То, что после сброса фамилии произошла унификация с Маяковским
--- это не более чем совпадение. На самом деле это просто
оказался единственный объект без имени. Если добавить ещё одного
мужчину без имени, то он тоже получит имя ``Владимир'':

\begin{example}{}{}
?- clear_db(people1), db_copy(people, people1).
true.

?- obj_construct(citizen_v, 
      [sex, surname], [man, 'Pickwick'], New_ Man), 
   db_put_object(people1, New_Man, _).
\end{example}

\begin{example}{}{}
?- named_args_unify(people1, _, 
      [sex, surname], [man, 'Mayakovsky'] , Man), 
   obj_field(Man, name, 'Vladimir'), 
   obj_reset_fields([surname], Man, Man1), 
   db_bind_obj(people1, Man1), 
   dump_db([lf(1)], people1).

[40]: man_v(man,Adam,_G4946,_G4947,_G4948) 
man_v(woman,Eva,_G4946,_G4947,_G4948) 
citizen_v(man,_G4945,Pickwick,_G4947,_G4948,_G4949,_G4950,_G4951) 
citizen_v(man,Vladimir,Mayakovsky,_G4947,_G4948,[Soviet Union],_G49
50,_G4951)                                                        

<next solution>                                  

[41]: man_v(man,Adam,_G4943,_G4944,_G4945) 
man_v(woman,Eva,_G4943,_G4944,_G4945) 
citizen_v(man,Vladimir,Mayakovsky,_G4944,_G4945,[Soviet Union],_G49
47,_G4948)                                                        
citizen_v(man,Vladimir,Pickwick,_G4944,_G4945,[Soviet Union],_G4947
,_G4948)                                                          

<next solution>                                  

[42]: man_v(man,Adam,_G4946,_G4947,_G4948) 
man_v(woman,Eva,_G4946,_G4947,_G4948) 
citizen_v(man,Vladimir,Pickwick,_G4947,_G4948,[Soviet Union],_G4950
,_G4951)                                                          
citizen_v(man,Vladimir,Mayakovsky,_G4947,_G4948,[Soviet Union],_G49
50,_G4951)                                                        

<next solution>                                  

[43]: man_v(man,Adam,_G4946,_G4947,_G4948) 
man_v(woman,Eva,_G4946,_G4947,_G4948) 
citizen_v(man,Vladimir,Mayakovsky,_G4947,_G4948,[Soviet Union],_G49
50,_G4951)                                                        
citizen_v(man,Vladimir,Pickwick,_G4947,_G4948,[Soviet Union],_G4950
,_G4951)                                                          

...
\end{example}

однако, мы получили неожиданный побочный эффект. Наш предикат
даёт бесконечное множество решений. При анализе базы видно, что
Vladimir Pickwick и Vladimir Mayakovsky постоянно меняются
местами. Если добавить печать физических адресов, то можно
видеть, что при унификации в сторону базы в базе (это относится к
расширенной базе Пролога, но не обязательно ко всем реализациям)
создаётся новый объект, при этом старый удаляется. Таким образом,
унификация всегда находит новый объект в базе и порождает
бесконечное множество решений.

Для борьбы с данным свойством, присущим, вероятно, всем
Прологовским базам термов (из-за того, что их интерфейс построен
на assert/retract) необходимо, прежде всего, абстрагироваться от
механизма хранения и 
\begin{itemize}
\item[1)] никогда не искать объекты полным перебором базы; всегда
  использовать строгие условия отбора объектов (например, в
  данном случае, только объекты с ещё несвязанным именем);
\item[2)] унификацию в сторону базы всегда проводить для уже
  найденного путём унификации в сторону выражения объекта, не
  допуская перебора вариантов в bind_term_in_db;
\item[3)] по возможности использовать более высокоуровневые
  предикаты, совмещающие поиск и унификацию.
\end{itemize}

Сейчас мы продемонстрируем, как реализовать такой доступ на
низком уровне а затем перейдём к изложению высокоуровнего языка
запросов, который, как правило, и используется в \ur{} для
подобного рода операций.

\begin{example}{}{}
?- clear_db(people1), db_copy(people, people1).
true.

?- obj_construct(citizen_v, 
      [sex, surname], [man, 'Pickwick'], New_ Man), 
   db_put_object(people1, New_Man, _).
\end{example}

\begin{example}{}{}
?- named_args_unify(people1, _, 
      [sex, name, surname], [man, Name, ' Mayakovsky'], Man), 
   var(Name), 
   obj_field(Man, name, 'Vladimir'), 
   obj_reset_fields([surname], Man, Man1), 
   obj_pretty_print(Man1), 
   once(db_bind_obj(people1, Man1)), 
   dump_db([lf(1)], people1).

citizen_v ( 
  sex : man 
  name : Vladimir 
  country : [Soviet Union] 
) 

[79]: man_v(man,Adam,_G2584,_G2585,_G2586) 
man_v(woman,Eva,_G2584,_G2585,_G2586) 
citizen_v(man,_G2583,Pickwick,_G2585,_G2586,_G2587,_G2588,_G2589) 
citizen_v(man,Vladimir,Mayakovsky,_G2585,_G2586,[Soviet Union],_G25
88,_G2589)                                                        
 :[logging]
\end{example}

Вроде бы работает. Предикатом var мы отсекаем объекты со
звязанным именем а предикат once допускает bind_term_in_db
только с одним объектом в базе. Проблема в том, что как
показывает pretty print, Man1 может унифицироваться и на Pickwick
и на Mayakovsky (из-за того, что в нём не связана фамилия), но
once унифицирует только один, причём произвольный (в данном
случае, зависит от порядка занесения объектов в базу Пролога):

\begin{example}{}{}
?- clear_db(people1).
true.

?- obj_construct(citizen_v, [sex, surname], [man, 'Pickwick'], New_
Man), db_put_object(people1, New_Man, _).
New_Man = citizen_v(man, _G1437, 'Pickwick', _G1439, _G1440, _G1441
, _G1442, _G1443).                                                

?- db_copy(people, people1).
true.
\end{example}

(Pickwick оказался перед Mayakovsky)

\begin{example}{}{}
?- named_args_unify(people1, _, 
      [sex, name, surname], [man, Name, ' Mayakovsky'], Man), 
   var(Name), 
   obj_field(Man, name, 'Vladimir'), 
   obj_reset_fields([surname], Man, Man1), 
   obj_pretty_print(Man1), 
   once(db_bind_obj(people1, Man1)), 
   dump_db([lf(1)], people1).

citizen_v ( 
  sex : man 
  name : Vladimir 
  country : [Soviet Union] 
) 

[80]: man_v(man,Adam,_G2581,_G2582,_G2583) 
man_v(woman,Eva,_G2581,_G2582,_G2583) 
citizen_v(man,_G2580,Mayakovsky,_G2582,_G2583,[Soviet Union],_G2585
,_G2586)                                                          
citizen_v(man,Vladimir,Pickwick,_G2582,_G2583,[Soviet Union],_G2585
,_G2586)                                                          
 :[logging]
\end{example}

(и получился Vladimir Pickwick)

В связи с этой неоднозначностью необходимо дополнить правила
унификации в сторону базы следующим

\begin{itemize}
\item[4)] используйте ключи; проводите унификацию в сторону базы,
  выбирая нужный объект по ключевым полям.
\end{itemize}

Использованию ключей будет посвящена глава \ref{keys}. Сейчас же
мы рассмотрим высокоуровневые предикаты. 

\section{Поисковые запросы}

До сих пор мы рассматривали доступ к объектной базе, подобный
доступу к базе данных самого Пролога. Как уже было сказано,
прологовская база не единственная, на которой может быть
построена реализацию \ur-базы. В связи с этим, доступ с помощью
прямой низкоуровневой унификации, который использовался в
предыдущих разделах, не является оптимальным. Например, при
использовании любой реляционной базы боле эффективным является
доступ с помощью SQL запросов. \ur{} использует язык запросов
высокого уровня, который может отображаться либо в унификацию,
при использовании пролог реализации, либо в SQL, при
использовании внешней базы. Не смотря на то, что все предикаты
модуля ur_recorded_db работают и со внешней и со внутренней
базой, для наилучшей производительности рекомендуется
использовать язык запросов совместно с правильно подобранными
ключами (будут рассмотрены в разделе \ref{keys}).

Также следует иметь в виду, что проблема зацикливания, показанная
в разделе \ref{db_bind_obj}, как правило, не актуальна при
правильном построении выражения запроса и использовании
предикатов данного раздела.

Вот определение языка запроса в виде нотации Бэкуса-Науэра:

\begin{genexample}{}{}
expr ::= expr \/ expr
expr ::= expr /\ expr
expr ::= ( expr )
expr ::= field(Value) | field(+bound) | field(+free) | true
expr ::= field(\+ Value)
expr ::= functor(Functor) | functor(\+ Functor)
\end{genexample}
 
Операция \verb|\/| означает слияние двух подвыражений по ИЛИ,
\verb|/\| - по И. Вместо \verb|field| необходимо подставить имя
поля объекта, вместо Value - переменную либо
значение. \verb|+bound|, \verb|+free| и \verb|true| - это
лексемы.

Вот примеры правильных выражений:

\begin{verbatim}
name(+free)   
% объект имеет несвязанное поле name

sex(+bound)   
% объект имеет связанное поле sex

name('Vladimir') /\ sex(man) 
% объект - мужчина по имени Vladimir

name('Vladimir') /\ name(+bound) 
% избыточное выражение, field(Value) подразумевает связанность

country(\+ 'Soviet Union') 
% объект имеет поле country со значением, не равным Soviet Union

country(\+ 'Soviet Union') /\ country(+bound) 
% избыточное выражение, \+ Value как и Value 
% подразумевает конкретное  (связанное) значение

(country('Soviet Union') \/ country(+free)) /\ name('Vladimir') 
% человек, потенциально, из SU

functor(callup_v)
% военнообязанный

true
% выбор всех объектов
\end{verbatim}

Во всех приведённых примерах в качестве Value использовались
конкретные значения. Разумеется, можно использовать переменные
Пролога. Но. Все переменные в поисковом выражении должны быть
связаны до вызова предиката. Иначе выражение {\bf всегда} даёт
пустое множество найденных элементов.

Перейдём к рассмотрению конкретных предикатов.

\subsection{db_iterate/3}
\label{db_iterate/3}

db_iterate является аналогом db_recorded + унификация

% секция для объектов-оболочек

В простейшем случае он перебирает все элементы (сравните с
\ref{all_db_print}) 

\begin{example}{}{}
?- db_iterate(people, true, Man), obj_pretty_print(Man), fail; true
.                                                                 
man_v ( 
  sex : man 
  name : Adam 
) 
man_v ( 
  sex : woman 
  name : Eva 
) 
citizen_v ( 
  sex : man 
  surname : Mayakovsky 
  country : [Soviet Union] 
) 
\end{example}

Аналогично можно привести аналоги ранее приведённых примеров. Вот
аналог \ref{find_men}

\begin{example}{}{}
?- db_iterate(people, sex(man), Man).

Man = man_v(man, 'Adam', _G1440, _G1441, _G1442) ;

Man = citizen_v(man, _G1445, 'Mayakovsky', _G1447, _G1448, ['Soviet
 Union'], _G1450, _G1451) ;                                       
\end{example}

В отличии от унификации, мы не можем использовать значения для
унификации с несвязанными элементами. Например

\begin{example}{}{}
?- db_iterate(people, name('Adam') /\ surname('Mayakovsky'), Man). 
false.
\end{example}

однако, в то же время, можем свободно оперировать связностью:

\begin{example}{}{}
?- db_iterate(people, (name(+bound) /\ surname(+free)) \/ (name(+fr
ee) /\ surname(+bound)), Man).                                     
Man = man_v(man, 'Adam', _G1619, _G1620, _G1621) ;
Man = man_v(woman, 'Eva', _G1619, _G1620, _G1621) ;
Man = citizen_v(man, _G1624, 'Mayakovsky', _G1626, _G1627, ['Soviet
 Union'], _G1629, _G1630) ;                                       
false.
\end{example}

(возвращает все объекты, для которых либо имя не определено, либо
фаилия. Обратите внимание на использование скобок в поисковом
выражении. Сравните с \ref{adam_mayakovsky}).

\subsection{db_iterate/4}

% Следует переделать с учётом объектов-оболочек

Аналогично предикатам низкого уровня, мы можем получить
физические адреса, например, для удаления объектов. Вот пример
получения ``мужской'' и ``женской'' базы:

\begin{example}{}{}
?- db_copy(people, men), db_copy(people, women).

?- db_iterate(men, sex(\+ man), _, Ref), % select no man
   db_erase(Ref), fail; true.

?- db_iterate(women, sex(\+ woman), _, Ref), % select no woman
   db_erase(Ref), fail; true.

?- dump_db([lf(1)], men), dump_db([lf(1)], women).

[84]: man_v(man,Adam,_G1844,_G1845,_G1846) 
citizen_v(man,_G1843,Mayakovsky,_G1845,_G1846,[Soviet Union],_G1848
,_G1849)                                                          
 :[logging]
[85]: man_v(woman,Eva,_G1904,_G1905,_G1906) 
 :[logging]
\end{example}

Получилось.

Возвращаясь к вопросу, поставленному в разделе
\ref{class_descendant}. Добавим мужской шампунь (\ref{shampoo_v}):

\begin{example}{}{}
?- obj_construct(shampoo_v, [firm, sex], 
                 ['Schwarzkopf', man], Obj),
    db_put_object(people, Obj, _).
\end{example}

% w/2

Как ни странно, но запрос с использованием вычислимых полей
работать не будет:

\begin{example}{}{}
?- db_iterate(people, 
      sex(\+ man) \/ (class(\+ man_v) \/ class(\+ citizen_v)), 
      _, Ref), 
   db_erase(Ref), fail; true.                    

?- dump_db([lf(1)], people).
[90]: man_v(man,Adam,_G1844,_G1845,_G1846) 
citizen_v(man,_G1843,Mayakovsky,_G1845,_G1846,[Soviet Union],_G1848,_G1849)                                                          
shampoo_v(_G1842,Schwarzkopf,man) 
 :[logging]
\end{example}

Видно, что шампунь присутствует.

Данное свойство поисковых выражением объясняется требованием их
эффективной реализации. Вычислимые поля на Прологе нельзя
подставить в SQL запрос при использовании внешней
базы. Единственным исключением является поле functor, для
которого предусмотрен соответствующий запрос (functor --- это, по
сути, имя таблицы, при использовании SQL).

\begin{example}{}{}
?- db_iterate(people, functor(shampoo_v), _, Ref).

?- db_iterate(people, functor(\+ shampoo_v), _, Ref).
\end{example}

В случае необходимости фильтрации по другим вычислимым полям
(например, class), на помощь приходит вторая форма предиката -
db_iterate/4.

\subsection{db_iterate/4}

Необходимость различать предикаты Пролога по арности приводит к
тому, что каждая новая форма предиката получает дополнительный
аргумент. Так предикат, позволяющий использовать дополнительную
фильтрацию

\begin{verbatim}
db_iterate(+DB_Key, +Query, +Filter_Pred, -Object)
\end{verbatim}


наследует все поля предыдущей формы (а потому всегда возвращает
физический адрес объекта). Дополнительно он получает параметр
Pred, который должен иметь арность 1. Для каждого объекта,
удовлетворяющего Query будет вызван Pred. Если Pred вернёт false,
объект будет пропущен. Передача true в качестве Pred аналогична
вызову db_iterate/4.

....

Вот аналог примера \ref{all_men_print}, фильтрующего шампуни из
базы people. Для начала созданим вспомогательный предикат
check_man/1:

\begin{example}{}{}
check_man(Object) :- obj_field(Object, class, Class), 
   ( Class = man_v 
   ; class_descendant(man_v, Class)
   ), !.
\end{example}

(он аналогичен тому, который использовался в примере
\ref{all_men_print}, только использует class вместо functor,
см. \ref{downcast}). После этого желаемый результат достигается
применением db_iterate/5:

\begin{example}{}{}
?- db_iterate(people, sex(man), check_man, Man), 
   obj_pretty_print(Man), fail; true.

man_v ( 
  sex : man 
  name : Adam 
) 
% Examples/callup_v.pl compiled into callup_v 0.00 sec, 1,480 bytes
citizen_v ( 
  sex : man 
  surname : Mayakovsky 
  country : [Soviet Union] 
) 
\end{example}

Обратите внимение на автоматическую подгрузку объекта
callup_v. Это потому, что, как мы помним (\ref{downcast})
\verb|obj_field(Man, class, callup_v)| для Mayakovsky, и
вычисление class_descendant/2 потребовало загрузить определение
этого объекта.

В качестве 3-го параметра можно передавать также предикат,
выполняющий какое-либо действие. Например, для печати всех
объектов базы можно было бы использовать

\begin{example}{}{}
?- db_iterate(people, true, obj_pretty_print, _), fail; true.
\end{example}

Однако, это уже похоже на трюки.

\subsection{db_iterate_replace/3}
\label{db_iterate_replace/3}

Как было сказано в \ref{db_bind_obj}, предикаты, работающие с
поисковыми выражениями (они были отнесены к предикатам высокого
уровня) позволяют писать более простые запросы, которые меняют
объекты в базе, в частности, заполняют несвязанные поля, чем
предикаты низкого уровня, к которым относятся db_recorded, \na,
db_erase и db_bind_obj.

Сейчас мы это продемонстрируем. В разделе \ref{db_bind_obj}
был рассмотрен пример (\ref{vladimir_to_all_mayakovsky}), в
котором все Маяковские получали имя Владимир. Вот как его можно
переписать с использованием db_iterate_replace/3. Для начала, как
и для db_iterate, определим вспомогательный предикат. Только это
будет предикат-заменитель объекта, его арность должна быть не
менее 3:

\begin{example}{}{}
set_fields(Fields, Values, Obj_In, Obj_Out, true) :- 
   obj_reset_fields(Fields, Obj_In, Obj_Out), 
   named_args_unify(Obj_Out, Fields, Values). 
\end{example}

Мы использовали универсальный подход, и, вместо того, чтобы
задать предикат, устанавливающий имя, создали предикат, который
может списку полей присвоить список значений, предварительно
сбросив их, если данные поля были уже связанными. Предикат, как
было сказано, должен иметь арность не меньше 3-х и
db_iterate_replace будет вызывать его как Pred/3, \te два первых
аргумента мы будем задавать при вызове. Из последних 3-х
аргументов первый получает объект, найденный в базе, второй
должен вернуть ему замену, и в последнем мы будем возвращать
всегда true при использовании с db_iterate_replce/3.

Теперь, собственно, задание имени (аналог примера
\ref{vladimir_to_all_mayakovsky}):

\begin{example}{}{}
?- clear_db(people1), db_copy(people, people1).

?- db_iterate_replace(people1, 
      set_fields([name], ['Vladimir']), 
      surname('Mayakovsky') /\ name(+free)
      ).

?- dump_db([lf(1)], people1).
[6]: man_v(man,Adam,_G384,_G385,_G386) 
man_v(woman,Eva,_G384,_G385,_G386) 
shampoo_v(_G382,Schwarzkopf,man) 
citizen_v(man,Vladimir,Mayakovsky,_G385,_G386,[Soviet Union],_G388,
_G389)                                                            
 :[logging]
\end{example}

Очевидно, это читается гораздо проще, чем в примере
\ref{vladimir_to_all_mayakovsky}. К тому же, в данном случае,
имеет б\'oльшую гибкость:

\begin{example}{}{}
?- db_iterate_replace(people1, 
      set_fields([surname], ['Smith']), 
      surname(+free)
   ). 

?- dump_db([lf(1)], people1).
[7]: shampoo_v(_G382,Schwarzkopf,man) 
citizen_v(man,Vladimir,Mayakovsky,_G385,_G386,[Soviet Union],_G388,
_G389)                                                            
man_v(man,Adam,Smith,_G385,_G386) 
man_v(woman,Eva,Smith,_G385,_G386) 
 :[logging]
\end{example}

(можно даже сбрасывать поля:)

\begin{example}{}{}
?- db_iterate_replace(people1, 
      set_fields([sex, surname], [_, _]), 
      sex(+bound)
   ).                                                     

?- dump_db([lf(1)], people1).
[10]: shampoo_v(_G385,Schwarzkopf,man) 
citizen_v(_G385,Vladimir,_G387,_G388,_G389,[Soviet Union],_G391,_G3
92)                                                               
man_v(_G385,Adam,_G387,_G388,_G389) 
man_v(_G385,Eva,_G387,_G388,_G389) 
 :[logging]
\end{example}

(вопрос внимательному читателю - почему шампунь не сбросил
значение man в последнем примере?)

Во всех трёх примерах запрос поиска содержит компонент, который
исключает повторное попадание изменённой записи на вход базы. Как
было показано в \ref{db_bind_obj} это обязательно.

Можно построить запрос меняющий также классы объектов. Для этого
подойдёт такой рабочий предикат:

\begin{example}{obj_downcast для db_iterate_replace}{downcast/3}
downcast(Obj_In, Obj_Out, true) :- obj_downcast(Obj_In, Obj_Out).
\end{example}

Вопрос в заключается в правильном поисковом
запросе. \verb|db_iterate_replace(people1, downcast, true)|
использовать не получится, так как \verb|true| не задерживает уже
обработанные записи. По некотором размышлении, можно прийти к
выводу, что в данном случае необходимо задействоват
дополнительные поля. Их можно задать в общем предке (что-то вроде
\verb|flag|), однако, на практике, зачастую можно использовать
уже имеющиеся в объекте поля. Попробуем решить задачу ``в лоб''
(предупреждение - решение крайне не элегантное). Мы знаем, что у
всех объектов базы people есть поле sex. Его и постараемся
задействовать.

\begin{example}{}{}
ugly_downcast(Obj_In, Obj_Out, true) :- 
   obj_downcast(Obj_In, Obj2),
   obj_reset_fields([sex], Obj2, Obj_Out),
   obj_field(Obj_In, sex, Sex),
   atom_concat(Sex, '_', New_Sex),
   obj_field(Obj_Out, sex, New_Sex).
\end{example}

\begin{example}{Уродливый downcast}{ugly_downcast_replacing}
?- clear_db(people1), db_copy(people, people1).

?- db_iterate_replace(people1, 
      ugly_downcast, sex(man) \/ sex(woman)).

?- dump_db([lf(1)], people1).
[12]: man_v(man_,Adam,_G2468,_G2469,_G2470) 
man_v(woman_,Eva,_G2468,_G2469,_G2470) 
callup_v(man_,_G2467,Mayakovsky,_G2469,_G2470,[Soviet Union],_G2472
,_G2473,_G2474)                                                   
shampoo_v(_G2466,Schwarzkopf,man_) 
 :[logging]
\end{example}

теперь вернёмся к нормальным значениям поля sex

\begin{example}{}{}
?- db_iterate_replace(people1, 
      set_fields([sex], [man]), sex(man_)).

?- db_iterate_replace(people1, 
      set_fields([sex], [woman]), sex(woman_)).

?- dump_db([lf(1)], people1).
[13]: man_v(man,Adam,_G2468,_G2469,_G2470) 
callup_v(man,_G2467,Mayakovsky,_G2469,_G2470,[Soviet Union],_G2472,
_G2473,_G2474)                                                    
shampoo_v(_G2466,Schwarzkopf,man) 
man_v(woman,Eva,_G2468,_G2469,_G2470) 
 :[logging]
\end{example}

не то, чтобы мы не достигли результата, но, правильная, с точки
зрения математики, последовательность оказывается неподходящей
для написания программ. Поэтому, логично ожидать наличия других
вариантов функции db_iterate_replace.

\subsection{db_iterate_replcae/4}

Как и db_iterate/4, этот предикат использует дополнительный
предикат-фильтр для добавления к поисковому выражению. С его
помощью мы можем переписать
\ref{ugly_downcast_replcaing}. Добавим, только, ещё один
предикат:

\begin{example}{}{}
not_downcasted(Obj) :- 
   obj_field(Obj, class, Class1),
   obj_field(Obj, functor, Class2),
   Class1 \= Class2.
\end{example}

\begin{example}{}{}
?- db_iterate_replace(people1, downcast, true, not_downcasted).

?- dump_db([lf(1)], people1).
[14]: man_v(man,Adam,_G2468,_G2469,_G2470) 
man_v(woman,Eva,_G2468,_G2469,_G2470) 
shampoo_v(_G2466,Schwarzkopf,man) 
callup_v(man,_G2467,Mayakovsky,_G2469,_G2470,[Soviet Union],_G2472,
_G2473,_G2474)                                                    
 :[logging]
\end{example}

Итак, как оказалось, наличие языка запросов не ограничивает нас в
использовании обычных предикатов Пролога для поиска значений. В
самых ``безнадёжных'' случаях поисковое выражение вырождается,
как в данном случае, в простое \verb|true|. Однако учтите, в этом
случае Пролог будет просматривать всю базу. Потому решение с
флагом в объекте-предке, упомянутое в \ref{db_iterate_replace/3}
оказывается эффективнее для больших SQL баз.

%\subsection{db_reset/3}
%\label{db_reset/3}

%\subsection{db_change/4}
%\label{db_change/4}



\section{Использование ключей}
\label{keys}

% Обновить раздел

В примере \ref{db_erase_example} было показано использование
предиката db_copy/2 для создания двух вспомогательных
баз. Вообще говоря, \ur{} не имеет отдельного предиката для
создания базы, равно как и для её удаления. Потому, всякое
упоминание новой базы с помещением в неё объектов может эту базу
создавать. 

Давайте исследуем, что произойдёт, если предикат db_copy/2
использовать несколько раз.

\begin{example}{}{}
?- clear_db(people1), db_copy(people, people1), db_copy(people,
  people1), dump_db([lf(1)], people1).

[9]: man_v(man,Adam,_G742,_G743,_G744) 
man_v(woman,Eva,_G742,_G743,_G744) 
citizen_v(man,_G741,Mayakovsky,_G743,_G744,[Soviet Union],_G746,_G7
47)                                                               
man_v(man,Adam,_G742,_G743,_G744) 
man_v(woman,Eva,_G742,_G743,_G744) 
citizen_v(man,_G741,Mayakovsky,_G743,_G744,[Soviet Union],_G746,_G7
47)                                                               
 :[logging]
\end{example}

Можно видеть, что записи для каждого объекта дублируются.

Данное свойство может нарушать логическую целостность в том
случае, когда нам надо моделировать {\it существование}
объектов. В этом случае существование одного человека с именем
Adam должно обозначаться единственным объектом в базе, а у нас
получилось два Adam-а --- непонятно, это два человека или один,
представленный несколькими записями.

Мы можем принять соглашение, что объекты различаются физическими
адресами. Однако этот метод крайне несовершенен. Сейчас мы
продемонстрируем почему.

\subsection{Несостоятельность различения объектов по физическим
  адресам}

С первого взгляда может показаться, что физический адрес в базе -
это аналог указателя в C++ или Java. В соответствии с моделями
этих языков два разных указателя - это два объекта.

Однако, модель ``памяти объектов'' в Uranium несколько иная.

\begin{enumerate}

\item Объект может претерпевать изменения downcast
  (\ref{downcast}). Соответственно, при использовании той же SQL
  базы один и тот же объект будет представлен разными таблицами,
  а следовательно, он будет менять физический адрес.

\item При сколько-нибудь сложной обработке реальных
  бизнес-объектов в \ur{} мы будем часто использовать несколько
  баз. Например, статья на сайте может представляться
  \begin{itemize}
  \item[а)] в виде заголовка;
  \item[б)] в виде краткой аннотации (в общем списке);
  \item[в)] в виде полной версии на отдельной странице
  \end{itemize}

  но это будет одна и та же статья и, в терминах MVC
  (Model-Controller-View) архитектуры, это есть один объект,
  имеющий разнообразные View. При извлечении её с сайта (анализе
  различных страниц) разные её View могут помещаться в разное
  время в разные базы, однако, эти разные записи будут относиться
  к одному объекту и могут, например, потом дополнять друг друга
  (см. \ref{db_merge}).

\item И, наконец, идентификация объектов с помощью физических
  адресов - не гибкий механизм, он зависит от реализации
  базы. Для него нет общей схемы.

\end{enumerate}


\subsection{Другие способы различения объектов}

К другим способам различения объектов относятся различение по
специальному идентификатору, уникальному для каждого объекта и с
помощью функции тестирования двух объектов, которая должна
вернуть true, если это один и тот же объект. Оба этих способа
укладываются в концепцию ключевых полей.


\subsection{Концепция ключевых полей \ur}

В \ur{} ключевое поле --- это свойство объекта. В других
системах, как правило, о ключах говорят только применительно к
базе. В \ur{} можно сказать, что ключ существует вместе с
объектом, но автоматически обрабатывается только при операциях с
базой. Давайте рассмотрим, для начала, концепцию ключа в
непривычной, оторванной от базы форме.

Изменим определение объекта man_v

\begin{example}{}{}
:- module(man_v, []).

new_class(man_v, object_v, [sex, name, surname, weight, height]
         , [name, surname]
         ).
\end{example}

Мы всегда можем проверить наличие ключа в объекте с помощью
предиката get_key/2 модуля ur_objects. Это, в некотором роде,
аналог class_fields, о котором шла речь в \ref{upcast} за тем
исключением, что предикат get_key/2 может работать с двумя типами
данных - именами классов и объектами.

\begin{example}{}{}
?- get_key(man_v, Key).

Key = [name, surname].
\end{example}

\begin{example}{}{}
?- obj_construct(man_v, [], [], Obj), 
   get_key(Obj, Key).

Obj = man_v(_G15, _G16, _G17, _G18, _G19),
Key = [name, surname].
\end{example}

Ключ наследуется

\begin{example}{}{}
?- get_key(callup_v, Key).

Key = [name, surname].
\end{example}

(более подробно наследование ключей рассматривается в
\ref{keys_inheritance}).

Также можно, одним предикатом, получить значение полей,
соответствующих ключам:

\begin{example}{}{}
?- obj_construct(man_v, [name], ['Alex'], Obj), 
   get_key_value(Obj, Key_Vals).                                                        

Obj = man_v(_G918, 'Alex', _G920, _G921, _G922),
Key_Vals = ['Alex', _G920].
\end{example}

\subsection{Работа с ключами ``в ручную''}

Для иллюстрации ручной работы с ключами давайте воспользуемся
``нерекоммендованным приёмом'' (он может быть очень ресурсоёмким)
и поместим объекты в список. Для удобства напишем предикат,
который создаёт сразу множество объектов:

\begin{example}{}{}
make_obj_list(List, Objects) :-

   maplist(make_obj_list2, List, Objects2),
   flatten(Objects2, Objects).

make_obj_list2((Class, Fields, List), Objects) :-

   findall(Object,
           (  member(Values, List),
              obj_construct(Class, Fields, Values, Object)
           ),
           Objects
          ).
\end{example}

теперь можно создать с помощью него список таким образом:

\begin{bigexample}{Список для ручной работы с ключами}%
                  {key_sample_list}
?- make_obj_list([
     (man_v, [sex, name, height],
        [[man, 'Adam', 1.74], 
         [women, 'Eva', 1.68]]
     ),
     (man_v, [sex, name, surname, weight, height],
        [[man, 'Mike', 'Tison', 4.1, 0.54],
         [man, 'Mike', 'Tison', 16, 1.1],
         [man, 'Mike', 'Tison', 99, 2.1],
         [man, 'Vladimir', 'Klichko', 99, 2]]
     ),
     (citizen_v, [sex, name, surname, country, birthday],
        [[man, 'Vladimir', 'Mayakovsky', ['Soviet Union'], 1900],
         [man, 'Adam', 'Mitskevich', ['Poland'], 1920],
         [women, 'Clara', 'Wieck', ['Germany'], 1800]]
     )],
     Src_List),
   assert(src_list(Src_List)).
\end{bigexample}

Давайте реализуем предикат, проверяющий существование {\it
  конкретного\/} объекта в списке.

Первое, что может прийти на ум, это использовать, в каком-то
виде, унификацию:

\begin{example}{}{}
?- src_list(Src_List),
   obj_construct(man_v, [surname], ['Strauss'], Obj), 

   %% our predicate
   findall(Obj, member(Obj, Src_List), Found_List), 
   %%

   maplist(obj_pretty_print, Found_List).                         

man_v ( 
  sex : man 
  name : Adam 
  surname : Strauss 
  height : 1.74 
) 
man_v ( 
  sex : woman 
  name : Eva 
  surname : Strauss 
  height : 1.68 
) 
\end{example}

Естественно, как уже было показано, несвязанные поля ``рады''
принять любое значение.

Можно потребовать, чтобы все ключевые поля в поисковом запросе
были связаны. Действительно, только ключ идентифицирует объект, а
мы договорились искать {\it конкретный\/} объект.

\begin{example}{}{}
?- src_list(L), 
   obj_construct(man_v, 
      [name, surname], ['Adam', 'Mitskevich'], Obj), 

   %%
   get_key_value(Obj, Key_Val), 
   ground(Key_Val), % search only if the key is bound

   findall(Obj, member(Obj, L), Found_List), 
   %%

   maplist(obj_pretty_print, Found_List).

man_v ( 
  sex : man 
  name : Adam 
  surname : Mitskevich 
  height : 1.74 
) 
\end{example}

Уже лучше. Если вспомнить, что говорилось в \ref{object_life} о
жизни объектов, то результат вполне адекватный --- полученный на
выходе предиката список Found_List можно воспринимать как
поправку-условие, то есть, предикат сообщает нам, при каком
допущении производился поиск. В данном случае, мы допустили, что
фамилия Адама была Мицкевич и честно об этом сообщили. Для более
корректной формы входных/выходных данных, однако,
список-допущение не следует смешивать со
списком-результатом. Тогда мы можем написать, в первом
приближении, следующее:

\begin{bigexample}{Предикат поиска объекта в списке}{obj_search}
obj_search(List_In, List_Out, Obj, Found_List) :-

   get_key_value(Obj, Key_Val), 
   (   ground(Key_Val)
   ->  true
   ;   throw(unbound_key(Obj))
   ),
   obj_search2(List_In, List_Out, Obj, [], Found_Rev),
   reverse(Found_Rev, Found_List).


obj_search2([], [], _, Found_List, Found_List) :- !.

obj_search2([H_In|T_In], [H_Out|T_Out], Obj, Found_In, Found_Out) :-

   H_Out = H_In,

   (   Obj = H_In 
   ->  Found2 = [Obj|Found_In]
   ;   Found2 = Found_In
   ),
   
   obj_search2(T_In, T_Out, Obj, Found2, Found_Out).
\end{bigexample}

\begin{example}{}{}
?- db_to_list(people, _, L), 
   obj_construct(man_v, 
      [name, surname], ['Adam', 'Mitskevich'], Obj), 
   obj_search(L, L2, Obj, Found_List).  

L = [man_v(man, 'Adam', 'Mitskevich', _G56, _G57), man_v(woman, 'Ev
a', _G46, _G47, _G48), citizen_v(man, _G30, 'Mayakovsky', _G32, _G3
3, ['Soviet Union'], _G35, _G36)],                                

L2 = [man_v(man, 'Adam', 'Mitskevich', _G56, _G57), man_v(woman, 'E
va', _G46, _G47, _G48), citizen_v(man, _G30, 'Mayakovsky', _G32, _G
33, ['Soviet Union'], _G35, _G36)],                               

Found_List = [man_v(man, 'Adam', 'Mitskevich', _G56, _G57)].
\end{example}

Можно видеть, что приведённая реализация предиката работает
вполне корректно.

Давайте теперь немного поэкспериментируем с самими объектами.

Давайте поищем теперь Майка Тайсона

\begin{example}{}{}
?- src_list(Src_List),
   obj_construct(man_v, [name, surname], ['Mike', 'Tison'], Obj), 
   obj_search(Src_List, New_List, Obj, Found).

Found = [man_v(man, 'Mike', 'Tison', 4.1, 0.54)].
\end{example}

Но позвольте, почему только один и, притом, самый маленький?
Ответ кроется в ``жадности'' несвязанных полей Пролога. Как
только они получают значение, они с ним уже не могут расстаться.

Логика поиска подсказывает нам, что поля объекта-шаблона должны
оставаться несвязанными. К счастью, в Прологе существует предикат
copy_term, который позволяет создать ``отвязанную'' копию объекта
прежде, чем он унифицируется. Вот соответсвующая модификация
предиката \ref{obj_search}:

\begin{example}{}{}
\end{example}


% Упражнение - реализовать сортировку объектов по ключу


\subsection{Ключи в базе}

+db_put_object
+db_erase_object/3
+db_merge

+ опция overwrite в db_iterate_replace/3 + несовершенства примера
низкоуровневая унификация в базу


\subsection{Ключи и наследование}
\label{keys_inheritance}

+ пример с id в citizen_v. Необходимость сохранять ключ родителя.

(возможно, рассмотреть вариант перенесение id в базовый класс для
man_v)

Определение базового класса базы.

Слияние объектов (пример).


Использование ключей в объектах

Использование типизированных полей

obj_diff и obj_merge

могут ли вычислимые поля перекрывать обычные. Country_List

\section{Некоторые более сложные примеры, использующие объекты и
  базу}

\subsection{Автозаполнение дополнительных полей при downcast}

При даункасте, как правило, к объекту добавляются дополнительные
поля (они всегда добавляются, если наследник расширяет набор
полей родителя, что, как правило, и происходит). Так как
несвязанные поля у нас --- нормальное рабочее состояние объекта
(что не знаем, то не связываем), то вполне логично добавлять
всегда несвязанные значения для новых полей, что, собственно,
obj_downcast делает автоматически (\ref{obj_downcast}). Однако,
существует масса ситуаций, когда объект без какого-либо поля
вообще не имеет смысла (как вариант) или, даже, это поле
формирует ключ (\ref{keys}).

Давайте ещё раз посмотрим на определение citizen_v:

\begin{example}{}{}
:- module(citizen_v, []).

new_class(citizen_v, man_v, [country, id, birthday]).
\end{example}

Мы предусмотрели поле id, который существует во многих странах
для однозначной идентификации гражданина. Например, в Украине
этот идентификатор называется ИНН. Даже если он поменял имя и
фамилию, гражданина всегда можно найти по ИНН.

Для нас, однако, не важно, как именно формируется id. Для нас
(программы) важно, будем полагать, только то, чтобы каждый новый
гражданин получачал новый id. И чтобы не было одного и того же
градланина с двумя id (id в citizen_v, как мы договорились в
\ref{keys_inheritance}, формирует ключ).

\end{comment}

\begin{comment}

Некоторые правила написания кода

- если downcast использует значения полей то '*_v?'(Obj, class, Class) предикат
должен приводить к класу только, если значения полей в нужном домене.
\end{comment}

\end{document}

